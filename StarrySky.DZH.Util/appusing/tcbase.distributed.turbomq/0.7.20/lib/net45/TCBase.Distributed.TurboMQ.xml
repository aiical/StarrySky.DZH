<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TCBase.Distributed.TurboMQ</name>
    </assembly>
    <members>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.AbstractByteBuffer">
            <summary>
            Abstract base class implementation of a <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer"/>
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.AbstractByteBuffer.CheckReadableBytes(System.Int32)">
            <summary>
            Throws a <see cref="T:System.IndexOutOfRangeException"/> if the current <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.AbstractByteBuffer.ReadableBytes"/> of this buffer
            is less than <see cref="!:minimumReadableBytes"/>.
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.AbstractByteBufferAllocator">
            <summary>
            Abstract base class for <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBufferAllocator"/> instances
            </summary>
        </member>
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.ByteBufferUtil.Equals(TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer,System.Int32,TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer,System.Int32,System.Int32)”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.ByteBufferUtil.Equals(TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer,TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer)">
            <summary>
             Returns {@code true} if and only if the two specified buffers are
             identical to each other as described in {@link ByteBuf#equals(Object)}.
             This method is useful when implementing a new buffer type.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.ByteBufferUtil.SwapLong(System.Int64)">
            <summary>
             Toggles the endianness of the specified 64-bit long integer.
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.DotNetty.Buffers.ByteOrder.LittleEndian">
            <summary>
            Default on most Windows systems
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.AddComponent(TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer)">
            <summary>
             Add the given {@link IByteBuffer}.
            
             Be aware that this method does not increase the {@code writerIndex} of the {@link CompositeByteBuffer}.
             If you need to have it increased you need to handle it by your own.
            
             @param buffer the {@link IByteBuffer} to add
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.AddComponents(TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer[])">
            <summary>
             Add the given {@link IByteBuffer}s.
            
             Be aware that this method does not increase the {@code writerIndex} of the {@link CompositeByteBuffer}.
             If you need to have it increased you need to handle it by your own.
            
             @param buffers the {@link IByteBuffer}s to add
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.AddComponents(System.Collections.Generic.IEnumerable{TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer})">
            <summary>
             Add the given {@link IByteBuffer}s.
            
             Be aware that this method does not increase the {@code writerIndex} of the {@link CompositeByteBuffer}.
             If you need to have it increased you need to handle it by your own.
            
             @param buffers the {@link IByteBuffer}s to add
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.AddComponent(System.Int32,TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer)">
            <summary>
             Add the given {@link IByteBuffer} on the specific index.
            
             Be aware that this method does not increase the {@code writerIndex} of the {@link CompositeByteBuffer}.
             If you need to have it increased you need to handle it by your own.
            
             @param cIndex the index on which the {@link IByteBuffer} will be added
             @param buffer the {@link IByteBuffer} to add
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.AddComponents(System.Int32,TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer[])">
            <summary>
             Add the given {@link IByteBuffer}s on the specific index
            
             Be aware that this method does not increase the {@code writerIndex} of the {@link CompositeByteBuffer}.
             If you need to have it increased you need to handle it by your own.
            
             @param cIndex the index on which the {@link IByteBuffer} will be added.
             @param buffers the {@link IByteBuffer}s to add
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.AddComponents(System.Int32,System.Collections.Generic.IEnumerable{TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer})">
            <summary>
             Add the given {@link ByteBuf}s on the specific index
            
             Be aware that this method does not increase the {@code writerIndex} of the {@link CompositeByteBuffer}.
             If you need to have it increased you need to handle it by your own.
            
             @param cIndex the index on which the {@link IByteBuffer} will be added.
             @param buffers the {@link IByteBuffer}s to add
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.ConsolidateIfNeeded">
            <summary>
             This should only be called as last operation from a method as this may adjust the underlying
             array of components and so affect the index etc.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.RemoveComponent(System.Int32)">
            <summary>
             Remove the {@link IByteBuffer} from the given index.
            
             @param cIndex the index on from which the {@link IByteBuffer} will be remove
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.RemoveComponents(System.Int32,System.Int32)">
            <summary>
             Remove the number of {@link IByteBuffer}s starting from the given index.
            
             @param cIndex the index on which the {@link IByteBuffer}s will be started to removed
             @param numComponents the number of components to remove
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.Decompose(System.Int32,System.Int32)">
            <summary>
             Same with {@link #slice(int, int)} except that this method returns a list.
            </summary>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.NumComponents">
            <summary>
             Return the current number of {@link IByteBuffer}'s that are composed in this instance
            </summary>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.MaxNumComponents">
            <summary>
             Return the max number of {@link IByteBuffer}'s that are composed in this instance
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.ToComponentIndex(System.Int32)">
            <summary>
             Return the index for the given offset
            </summary>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.Item(System.Int32)">
            <summary>
             Return the {@link IByteBuffer} on the specified index
            
             @param cIndex the index for which the {@link IByteBuffer} should be returned
             @return buffer the {@link IByteBuffer} on the specified index
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.ComponentAtOffset(System.Int32)">
            <summary>
             Return the {@link IByteBuffer} on the specified index
            
             @param offset the offset for which the {@link IByteBuffer} should be returned
             @return the {@link IByteBuffer} on the specified index
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.InternalComponent(System.Int32)">
            <summary>
             Return the internal {@link IByteBuffer} on the specified index. Note that updating the indexes of the returned
             buffer will lead to an undefined behavior of this buffer.
            
             @param cIndex the index for which the {@link IByteBuffer} should be returned
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.InternalComponentAtOffset(System.Int32)">
            <summary>
             Return the internal {@link IByteBuffer} on the specified offset. Note that updating the indexes of the returned
             buffer will lead to an undefined behavior of this buffer.
            
             @param offset the offset for which the {@link IByteBuffer} should be returned
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.Consolidate">
            <summary>
             Consolidate the composed {@link IByteBuffer}s
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.Consolidate(System.Int32,System.Int32)">
            <summary>
             Consolidate the composed {@link IByteBuffer}s
            
             @param cIndex the index on which to start to compose
             @param numComponents the number of components to compose
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer.DiscardReadComponents">
            <summary>
             Discard all {@link IByteBuffer}s which are read.
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.DuplicatedByteBuffer">
            <summary>
            Dervied buffer that forwards requests to the original underlying buffer
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.EmptyByteBuffer">
            <summary>
            Represents an empty byte buffer
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer">
            <summary>
            Inspired by the Netty ByteBuffer implementation (https://github.com/netty/netty/blob/master/buffer/src/main/java/io/netty/buffer/ByteBuf.java)
            
            Provides circular-buffer-esque security around a byte array, allowing reads and writes to occur independently.
            
            In general, the <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer"/> guarantees:
            
            /// <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> LESS THAN OR EQUAL TO <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> LESS THAN OR EQUAL TO <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/>.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.AdjustCapacity(System.Int32)">
            <summary>
            Expands the capacity of this buffer so long as it is less than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.MaxCapacity"/>.
            </summary>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Allocator">
            <summary>
            The allocator who created this buffer
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.SetWriterIndex(System.Int32)">
            <summary>
            Sets the <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> of this buffer
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">thrown if <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> exceeds the length of the buffer</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.SetReaderIndex(System.Int32)">
            <summary>
            Sets the <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> of this buffer
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"> thrown if <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> is greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> or less than <c>0</c>.</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.SetIndex(System.Int32,System.Int32)">
            <summary>
            Sets both indexes
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">thrown if <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> exceeds the length of the buffer</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.IsReadable">
            <summary>
            Returns true if <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> - <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> is greater than <c>0</c>.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.IsReadable(System.Int32)">
            <summary>
            Is the buffer readable if and only if the buffer contains equal or more than the specified number of elements
            </summary>
            <param name="size">The number of elements we would like to read</param>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.IsWritable">
            <summary>
            Returns true if and only if <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/> - <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> is greater than zero.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.IsWritable(System.Int32)">
            <summary>
            Returns true if and only if the buffer has enough <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/> to accomodate <see cref="!:size"/> additional bytes.
            </summary>
            <param name="size">The number of additional elements we would like to write.</param>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Clear">
            <summary>
            Sets the <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> and <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> to <c>0</c>. Does not erase any of the data written into the buffer already,
            but it will overwrite that data.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.MarkReaderIndex">
            <summary>
            Marks the current <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> in this buffer. You can reposition the current <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/>
            to the marked <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> by calling <see cref="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ResetReaderIndex"/>.
            
            The initial value of the marked <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> is <c>0</c>.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ResetReaderIndex">
            <summary>
            Repositions the current <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> to the marked <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">is thrown if the current <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> is less than the 
            marked <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.MarkWriterIndex">
            <summary>
            Marks the current <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> in this buffer. You can reposition the current <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/>
            to the marked <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> by calling <see cref="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ResetWriterIndex"/>.
            
            The initial value of the marked <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> is <c>0</c>.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ResetWriterIndex">
            <summary>
            Repositions the current <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> to the marked <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">is thrown if the current <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> is greater than the 
            marked <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.DiscardReadBytes">
            <summary>
            Discards the bytes between the 0th index and <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/>.
            
            It moves the bytes between <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> to the 0th index,
            and sets <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> to <c>0</c> and <c>oldWriterIndex - oldReaderIndex</c> respectively.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.EnsureWritable(System.Int32)">
            <summary>
            Makes sure the number of <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WritableBytes"/> is equal to or greater than
            the specified value (<see cref="!:minWritableBytes"/>.) If there is enough writable bytes in this buffer,
            the method returns with no side effect. Otherwise, it raises an <see cref="T:System.ArgumentOutOfRangeException"/>.
            </summary>
            <param name="minWritableBytes">The expected number of minimum writable bytes</param>
            <exception cref="T:System.IndexOutOfRangeException"> if <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> + <see cref="!:minWritableBytes"/> > <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.MaxCapacity"/>.</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.GetBoolean(System.Int32)">
            <summary>
            Gets a boolean at the specified absolute <see cref="!:index"/> in this buffer.
            This method does not modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/>
            of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.GetByte(System.Int32)">
            <summary>
            Gets a byte at the specified absolute <see cref="!:index"/> in this buffer.
            This method does not modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/>
            of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.GetShort(System.Int32)">
            <summary>
            Gets a short at the specified absolute <see cref="!:index"/> in this buffer.
            This method does not modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/>
            of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.GetUnsignedShort(System.Int32)">
            <summary>
            Gets an ushort at the specified absolute <see cref="!:index"/> in this buffer.
            This method does not modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/>
            of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.GetInt(System.Int32)">
            <summary>
            Gets an integer at the specified absolute <see cref="!:index"/> in this buffer.
            This method does not modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/>
            of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.GetUnsignedInt(System.Int32)">
            <summary>
            Gets an unsigned integer at the specified absolute <see cref="!:index"/> in this buffer.
            This method does not modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/>
            of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.GetLong(System.Int32)">
            <summary>
            Gets a long integer at the specified absolute <see cref="!:index"/> in this buffer.
            This method does not modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/>
            of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.GetChar(System.Int32)">
            <summary>
            Gets a char at the specified absolute <see cref="!:index"/> in this buffer.
            This method does not modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/>
            of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.GetDouble(System.Int32)">
            <summary>
            Gets a double at the specified absolute <see cref="!:index"/> in this buffer.
            This method does not modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/>
            of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.GetBytes(System.Int32,TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer)">
            <summary>
            Transfers this buffers data to the specified <see cref="!:destination"/> buffer starting at the specified
            absolute <see cref="!:index"/> until the destination becomes non-writable.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.GetBytes(System.Int32,TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>
            Transfers this buffers data to the specified <see cref="!:destination"/> buffer starting at the specified
            absolute <see cref="!:index"/> until the destination becomes non-writable.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.GetBytes(System.Int32,TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer,System.Int32,System.Int32)">
            <summary>
            Transfers this buffers data to the specified <see cref="!:destination"/> buffer starting at the specified
            absolute <see cref="!:index"/> until the destination becomes non-writable.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.GetBytes(System.Int32,System.Byte[])">
            <summary>
            Transfers this buffers data to the specified <see cref="!:destination"/> buffer starting at the specified
            absolute <see cref="!:index"/> until the destination becomes non-writable.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.GetBytes(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Transfers this buffers data to the specified <see cref="!:destination"/> buffer starting at the specified
            absolute <see cref="!:index"/> until the destination becomes non-writable.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.SetBoolean(System.Int32,System.Boolean)">
            <summary>
            Sets the specified boolean at the specified absolute <see cref="!:index"/> in this buffer.
            
            This method does not directly modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.SetByte(System.Int32,System.Int32)">
            <summary>
            Sets the specified byte at the specified absolute <see cref="!:index"/> in this buffer.
            
            This method does not directly modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.SetShort(System.Int32,System.Int32)">
            <summary>
            Sets the specified short at the specified absolute <see cref="!:index"/> in this buffer.
            
            This method does not directly modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.SetUnsignedShort(System.Int32,System.Int32)">
            <summary>
            Sets the specified unsigned short at the specified absolute <see cref="!:index"/> in this buffer.
            
            This method does not directly modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.SetInt(System.Int32,System.Int32)">
            <summary>
            Sets the specified integer at the specified absolute <see cref="!:index"/> in this buffer.
            
            This method does not directly modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.SetUnsignedInt(System.Int32,System.UInt32)">
            <summary>
            Sets the specified unsigned integer at the specified absolute <see cref="!:index"/> in this buffer.
            
            This method does not directly modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.SetLong(System.Int32,System.Int64)">
            <summary>
            Sets the specified long integer at the specified absolute <see cref="!:index"/> in this buffer.
            
            This method does not directly modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.SetChar(System.Int32,System.Char)">
            <summary>
            Sets the specified UTF-16 char at the specified absolute <see cref="!:index"/> in this buffer.
            
            This method does not directly modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.SetDouble(System.Int32,System.Double)">
            <summary>
            Sets the specified double at the specified absolute <see cref="!:index"/> in this buffer.
            
            This method does not directly modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.SetBytes(System.Int32,TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer)">
            <summary>
            Transfers the <see cref="!:src"/> byte buffer's contents starting at the specified absolute <see cref="!:index"/>.
            
            This method does not directly modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.SetBytes(System.Int32,TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer,System.Int32)">
            <summary>
            Transfers the <see cref="!:src"/> byte buffer's contents starting at the specified absolute <see cref="!:index"/>.
            
            This method does not directly modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.SetBytes(System.Int32,TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer,System.Int32,System.Int32)">
            <summary>
            Transfers the <see cref="!:src"/> byte buffer's contents starting at the specified absolute <see cref="!:index"/>.
            
            This method does not directly modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.SetBytes(System.Int32,System.Byte[])">
            <summary>
            Transfers the <see cref="!:src"/> byte buffer's contents starting at the specified absolute <see cref="!:index"/>.
            
            This method does not directly modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.SetBytes(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Transfers the <see cref="!:src"/> byte buffer's contents starting at the specified absolute <see cref="!:index"/>.
            
            This method does not directly modify <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> of this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if the specified <see cref="!:index"/> is less than <c>0</c> or <c>index + 1</c> greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Capacity"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadBoolean">
            <summary>
            Gets a boolean at the current <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and increases the <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/>
            by <c>1</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadableBytes"/> is less than <c>1</c></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadByte">
            <summary>
            Gets a byte at the current <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and increases the <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/>
            by <c>1</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadableBytes"/> is less than <c>1</c></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadShort">
            <summary>
            Gets a short at the current <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and increases the <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/>
            by <c>2</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadableBytes"/> is less than <c>2</c></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadUnsignedShort">
            <summary>
            Gets an unsigned short at the current <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and increases the <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/>
            by <c>2</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadableBytes"/> is less than <c>2</c></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadInt">
            <summary>
            Gets an integer at the current <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and increases the <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/>
            by <c>4</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadableBytes"/> is less than <c>4</c></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadUnsignedInt">
            <summary>
            Gets an unsigned integer at the current <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and increases the <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/>
            by <c>4</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadableBytes"/> is less than <c>4</c></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadChar">
            <summary>
            Gets a 2-byte UTF-16 character at the current <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and increases the <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/>
            by <c>2</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadableBytes"/> is less than <c>2</c></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadDouble">
            <summary>
            Gets an 8-byte Decimaling integer at the current <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> and increases the <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/>
            by <c>8</c> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadableBytes"/> is less than <c>8</c></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadBytes(System.Int32)">
            <summary>
            Reads <see cref="!:length"/> bytes from this buffer into a new destination buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadableBytes"/> is less than <see cref="!:length"/></exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadBytes(TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer)">
            <summary>
            Transfers bytes from this buffer's data into the specified destination buffer
            starting at the curent <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> until the destination becomes
            non-writable and increases the <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> by the number of transferred bytes.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">if <see cref="!:destination.WritableBytes"/> is greaer than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadableBytes"/>.</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.SkipBytes(System.Int32)">
            <summary>
            Increases the current <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> by the specified <see cref="!:length"/> in this buffer.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"> if <see cref="!:length"/> is greater than <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadableBytes"/>.</exception>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.HasArray">
            <summary>
            Flag that indicates if this <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer"/> is backed by a byte array or not
            </summary>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Array">
            <summary>
            Grabs the underlying byte array for this buffer
            </summary>
            <value></value>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ToArray">
            <summary>
            Converts the readable contents of the buffer into an array.
            
            Does not affect the <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/> or <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/> of the <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer"/>
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Duplicate">
            <summary>
            Creates a deep clone of the existing byte array and returns it
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.Unwrap">
            <summary>
            Unwraps a nested buffer
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBufferAllocator">
            <summary>
            Thread-safe interface for allocating <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer"/> instances for use inside Helios reactive I/O
            </summary>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBufferHolder.Content">
            <summary>
            Return the data which is held by this {@link ByteBufHolder}.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBufferHolder.Copy">
            <summary>
            Create a deep copy of this {@link ByteBufHolder}.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBufferHolder.Duplicate">
            <summary>
            Duplicate the {@link ByteBufHolder}. Be aware that this will not automatically call {@link #retain()}.
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IllegalReferenceCountException">
            <summary>
            Exception thrown during instances where a reference count is used incorrectly
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.Unpooled">
            <summary>
            Utility class for managing and creating unpooled buffers
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.UnpooledByteBufferAllocator">
            <summary>
            Unpooled implementation of <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBufferAllocator"/>.
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.DotNetty.Buffers.UnpooledByteBufferAllocator.Default">
            <summary>
            Default instance
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.UnpooledHeapByteBuffer.#ctor(TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBufferAllocator,System.Int32,System.Int32)">
             <summary>
             Creates a new heap buffer with a newly allocated byte array.
            
             @param initialCapacity the initial capacity of the underlying byte array
             @param maxCapacity the max capacity of the underlying byte array
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Buffers.UnpooledHeapByteBuffer.#ctor(TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBufferAllocator,System.Byte[],System.Int32)">
             <summary>
             Creates a new heap buffer with an existing byte array.
            
             @param initialArray the initial underlying byte array
             @param maxCapacity the max capacity of the underlying byte array
             </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.DotNetty.Codecs.ByteToMessageDecoder.MergeCumulator">
            <summary>
            Cumulates instances of <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer"/> by merging them into one <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer"/>, using memory copies.
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.DotNetty.Codecs.ByteToMessageDecoder.CompositionCumulation">
            <summary>
            Cumulate instances of <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer"/> by add them to a <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer"/> and therefore avoiding memory copy when possible.
            </summary>
            <remarks>Be aware that <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.CompositeByteBuffer"/> use a more complex indexing implementation so depending on your use-case
            and the decoder implementation this may be slower then just use the <see cref="F:TCBase.Distributed.TurboMQ.DotNetty.Codecs.ByteToMessageDecoder.MergeCumulator"/>.
            </remarks>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Codecs.ByteToMessageDecoder.SingleDecode">
            <summary>
            Determines whether only one message should be decoded per <see cref="M:TCBase.Distributed.TurboMQ.DotNetty.Codecs.ByteToMessageDecoder.ChannelRead(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)"/> call.
            Default is <code>false</code> as this has performance impacts.
            </summary>
            <remarks>Is particularly useful in support of protocol upgrade scenarios.</remarks>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Codecs.ByteToMessageDecoder.ActualReadableBytes">
            <summary>
            Returns the actual number of readable bytes in the internal cumulative
            buffer of this decoder. You usually do not need to rely on this value
            to write a decoder. Use it only when you must use it at your own risk.
            This method is a shortcut to <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReadableBytes"/> of <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Codecs.ByteToMessageDecoder.InternalBuffer"/>.
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Codecs.CorruptedFrameException">
            <summary>
            A <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Codecs.DecoderException"/> which is thrown when the received frame data could not
            be decoded by an inbound handler.
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.DotNetty.Codecs.LengthFieldBasedFrameDecoder”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Codecs.LengthFieldBasedFrameDecoder.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a new instance.
            </summary>
            <param name="maxFrameLength">The maximum length of the frame.  If the length of the frame is
            greater than this value then <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Codecs.TooLongFrameException"/> will be thrown.</param>
            <param name="lengthFieldOffset">The offset of the length field.</param>
            <param name="lengthFieldLength">The length of the length field.</param>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Codecs.LengthFieldBasedFrameDecoder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a new instance.
            </summary>
            <param name="maxFrameLength">The maximum length of the frame.  If the length of the frame is
            greater than this value then <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Codecs.TooLongFrameException"/> will be thrown.</param>
            <param name="lengthFieldOffset">The offset of the length field.</param>
            <param name="lengthFieldLength">The length of the length field.</param>
            <param name="lengthAdjustment">The compensation value to add to the value of the length field.</param>
            <param name="initialBytesToStrip">the number of first bytes to strip out from the decoded frame.</param>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Codecs.LengthFieldBasedFrameDecoder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create a new instance.
            </summary>
            <param name="maxFrameLength">The maximum length of the frame.  If the length of the frame is
            greater than this value then <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Codecs.TooLongFrameException"/> will be thrown.</param>
            <param name="lengthFieldOffset">The offset of the length field.</param>
            <param name="lengthFieldLength">The length of the length field.</param>
            <param name="lengthAdjustment">The compensation value to add to the value of the length field.</param>
            <param name="initialBytesToStrip">the number of first bytes to strip out from the decoded frame.</param>
            <param name="failFast">
                If <c>true</c>, a <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Codecs.TooLongFrameException"/> is thrown as soon as the decoder notices the length
                of the frame will exceeed <see cref="F:TCBase.Distributed.TurboMQ.DotNetty.Codecs.LengthFieldBasedFrameDecoder.maxFrameLength"/> regardless of whether the entire frame has been
                read. If <c>false</c>, a <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Codecs.TooLongFrameException"/> is thrown after the entire frame that exceeds
                <see cref="F:TCBase.Distributed.TurboMQ.DotNetty.Codecs.LengthFieldBasedFrameDecoder.maxFrameLength"/> has been read.
            
                Defaults to <c>true</c> in other overloads.
            </param>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Codecs.LengthFieldBasedFrameDecoder.#ctor(TCBase.Distributed.TurboMQ.DotNetty.Buffers.ByteOrder,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create a new instance.
            </summary>
            <param name="byteOrder">The <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.ByteOrder"/> of the lenght field.</param>
            <param name="maxFrameLength">The maximum length of the frame.  If the length of the frame is
            greater than this value then <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Codecs.TooLongFrameException"/> will be thrown.</param>
            <param name="lengthFieldOffset">The offset of the length field.</param>
            <param name="lengthFieldLength">The length of the length field.</param>
            <param name="lengthAdjustment">The compensation value to add to the value of the length field.</param>
            <param name="initialBytesToStrip">the number of first bytes to strip out from the decoded frame.</param>
            <param name="failFast">
                If <c>true</c>, a <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Codecs.TooLongFrameException"/> is thrown as soon as the decoder notices the length
                of the frame will exceeed <see cref="F:TCBase.Distributed.TurboMQ.DotNetty.Codecs.LengthFieldBasedFrameDecoder.maxFrameLength"/> regardless of whether the entire frame has been
                read. If <c>false</c>, a <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Codecs.TooLongFrameException"/> is thrown after the entire frame that exceeds
                <see cref="F:TCBase.Distributed.TurboMQ.DotNetty.Codecs.LengthFieldBasedFrameDecoder.maxFrameLength"/> has been read.
            
                Defaults to <c>true</c> in other overloads.
            </param>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Codecs.LengthFieldBasedFrameDecoder.Decode(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext,TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer)">
            <summary>
            Create a frame out of the <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer"/> and return it.
            </summary>
            <param name="context">The <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext"/> which this <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Codecs.ByteToMessageDecoder"/> belongs to.</param>
            <param name="input">The <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer"/> from which to read data.</param>
            <returns>The <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer"/> which represents the frame or <c>null</c> if no frame could be created.</returns>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Codecs.LengthFieldBasedFrameDecoder.GetUnadjustedFrameLength(TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer,System.Int32,System.Int32,TCBase.Distributed.TurboMQ.DotNetty.Buffers.ByteOrder)">
            <summary>
             Decodes the specified region of the buffer into an unadjusted frame length.  The default implementation is
            capable of decoding the specified region into an unsigned 8/16/24/32/64 bit integer.  Override this method to
            decode the length field encoded differently. 
            Note that this method must not modify the state of the specified buffer (e.g. <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/>, 
            <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.WriterIndex"/>, and the content of the buffer.)
            </summary>
            <param name="buffer">The buffer we'll be extracting the frame length from.</param>
            <param name="offset">The offset from the absolute <see cref="P:TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer.ReaderIndex"/>.</param>
            <param name="length">The length of the framelenght field. Expected: 1, 2, 3, 4, or 8.</param>
            <param name="order">The preferred <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Buffers.ByteOrder"/> of <see cref="!:buffer"/>.</param>
            <returns>A long integer that represents the unadjusted length of the next frame.</returns>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Codecs.MessageToMessageEncoder`1.AcceptOutboundMessage(System.Object)">
            <summary>
            Returns {@code true} if the given message should be handled. If {@code false} it will be passed to the next
            {@link ChannelHandler} in the {@link ChannelPipeline}.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Codecs.MessageToMessageEncoder`1.Encode(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext,`0,System.Collections.Generic.List{System.Object})">
             <summary>
             Encode from one message to an other. This method will be called for each written message that can be handled
             by this encoder.
            
             @param context           the {@link ChannelHandlerContext} which this {@link MessageToMessageEncoder} belongs to
             @param message           the message to encode to an other one
             @param output           the {@link List} into which the encoded message should be added
                                  needs to do some kind of aggragation
             @throws Exception    is thrown if an error accour
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Codecs.Mqtt.MqttEncoder.DoEncode(TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBufferAllocator,TCBase.Distributed.TurboMQ.DotNetty.Codecs.Mqtt.Packets.Packet,System.Collections.Generic.List{System.Object})">
             <summary>
             This is the main encoding method.
             It's only visible for testing.
            
             @param bufferAllocator Allocates ByteBuf
             @param packet MQTT packet to encode
             @return ByteBuf with encoded bytes
             </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Codecs.TooLongFrameException">
            <summary>
            A <see cref="T:TCBase.Distributed.TurboMQ.DotNetty.Codecs.DecoderException"/> which is thrown when the length of the frame
            decoded is greater than the allowed maximum.
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Common.Concurrency.IPausableEventExecutor">
            <summary>
            Implement this interface if you need your {@link EventExecutor} implementation to be able
            to reject new work.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Common.Concurrency.IPausableEventExecutor.RejectNewTasks">
            <summary>
            After a call to this method the {@link EventExecutor} may throw a {@link RejectedExecutionException} when
            attempting to assign new work to it (i.e. through a call to {@link EventExecutor#execute(Runnable)}).
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Common.Concurrency.IPausableEventExecutor.AcceptNewTasks">
            <summary>
            With a call to this method the {@link EventExecutor} signals that it is now accepting new work.
            </summary>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Common.Concurrency.IPausableEventExecutor.IsAcceptingNewTasks">
            <summary>
            Returns {@code true} if and only if this {@link EventExecutor} is accepting a new task.
            </summary>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Common.Concurrency.SingleThreadEventExecutor.Scheduler">
            <summary>
            Task Scheduler that will post work to this executor's queue.
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Common.IReferenceCounted">
            <summary>
            Reference counting interface for reusable objects
            </summary>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Common.IReferenceCounted.ReferenceCount">
            <summary>
            Returns the reference count of this object
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Common.IReferenceCounted.Retain">
            <summary>
            Increases the reference count by 1
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Common.IReferenceCounted.Retain(System.Int32)">
            <summary>
            Increases the reference count by <see cref="!:increment"/>.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Common.IReferenceCounted.Release">
            <summary>
            Decreases the reference count by 1 and deallocates this object if the reference count reaches 0.
            </summary>
            <returns>true if and only if the reference count is 0 and this object has been deallocated</returns>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Common.IReferenceCounted.Release(System.Int32)">
            <summary>
            Decreases the reference count by <see cref="!:decrement"/> and deallocates this object if the reference count reaches 0.
            </summary>
            <returns>true if and only if the reference count is 0 and this object has been deallocated</returns>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Common.Utilities.ByteArrayExtensions">
            <summary>
            Extension methods used for slicing byte arrays
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Common.Utilities.MpscLinkedQueue`1.PeekNode">
            <summary>
             Returns the node right next to the head, which contains the first element of this queue.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Common.Utilities.MpscLinkedQueueNode`1.ClearMaybe">
            <summary>
            Sets the element this node contains to <code>null</code> so that the node can be used as a tombstone.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Common.Utilities.MpscLinkedQueueNode`1.Unlink">
            <summary>
            Unlink to allow GC
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Common.Utilities.ReferenceCountUtil.Retain``1(``0)">
            <summary>
            Try to call {@link ReferenceCounted#retain()} if the specified message implements {@link ReferenceCounted}.
            If the specified message doesn't implement {@link ReferenceCounted}, this method does nothing.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Common.Utilities.ReferenceCountUtil.Retain``1(``0,System.Int32)">
            <summary>
            Try to call {@link ReferenceCounted#retain(int)} if the specified message implements {@link ReferenceCounted}.
            If the specified message doesn't implement {@link ReferenceCounted}, this method does nothing.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Common.Utilities.ReferenceCountUtil.Release(System.Object)">
            <summary>
            Try to call {@link ReferenceCounted#release()} if the specified message implements {@link ReferenceCounted}.
            If the specified message doesn't implement {@link ReferenceCounted}, this method does nothing.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Common.Utilities.ReferenceCountUtil.Release(System.Object,System.Int32)">
            <summary>
            Try to call {@link ReferenceCounted#release(int)} if the specified message implements {@link ReferenceCounted}.
            If the specified message doesn't implement {@link ReferenceCounted}, this method does nothing.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Common.Utilities.ReferenceCountUtil.SafeRelease(System.Object)">
            <summary>
            Try to call {@link ReferenceCounted#release()} if the specified message implements {@link ReferenceCounted}.
            If the specified message doesn't implement {@link ReferenceCounted}, this method does nothing.
            Unlike {@link #release(Object)} this method catches an exception raised by {@link ReferenceCounted#release()}
            and logs it, rather than rethrowing it to the caller.  It is usually recommended to use {@link #release(Object)}
            instead, unless you absolutely need to swallow an exception.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Common.Utilities.ReferenceCountUtil.SafeRelease(System.Object,System.Int32)">
            <summary>
            Try to call {@link ReferenceCounted#release(int)} if the specified message implements {@link ReferenceCounted}.
            If the specified message doesn't implement {@link ReferenceCounted}, this method does nothing.
            Unlike {@link #release(Object)} this method catches an exception raised by {@link ReferenceCounted#release(int)}
            and logs it, rather than rethrowing it to the caller.  It is usually recommended to use
            {@link #release(Object, int)} instead, unless you absolutely need to swallow an exception.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Handlers.Tls.TlsHandshakeCompletionEvent.#ctor">
            <summary>
             Creates a new event that indicates a successful handshake.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Handlers.Tls.TlsHandshakeCompletionEvent.#ctor(System.Exception)">
            <summary>
             Creates a new event that indicates an unsuccessful handshake.
             Use {@link #SUCCESS} to indicate a successful handshake.
            </summary>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Handlers.Tls.TlsHandshakeCompletionEvent.IsSuccessful">
            <summary>
             Return {@code true} if the handshake was successful
            </summary>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Handlers.Tls.TlsHandshakeCompletionEvent.Exception">
            <summary>
             Return the {@link Throwable} if {@link #isSuccess()} returns {@code false}
             and so the handshake failed.
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.AbstractBootstrap`2">
             <summary>
             {@link AbstractBootstrap} is a helper class that makes it easy to bootstrap a {@link Channel}. It support
             method-chaining to provide an easy way to configure the {@link AbstractBootstrap}.
            
             <p>When not used in a {@link ServerBootstrap} context, the {@link #bind()} methods are useful for connectionless
             transports such as datagram (UDP).</p>
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Group(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IEventLoopGroup)">
            <summary>
            The {@link EventLoopGroup} which is used to handle all the events for the to-be-created
            {@link Channel}
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Channel``1">
            <summary>
            The {@link Class} which is used to create {@link Channel} instances from.
            You either use this or {@link #channelFactory(io.netty.channel.ChannelFactory)} if your
            {@link Channel} implementation has no no-args constructor.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.LocalAddress(System.Net.EndPoint)">
            <summary>
            The {@link SocketAddress} which is used to bind the local "end" to.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.LocalAddress(System.Int32)">
            <summary>
            @see {@link #localAddress(SocketAddress)}
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.LocalAddress(System.String,System.Int32)">
            <summary>
            @see {@link #localAddress(SocketAddress)}
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.LocalAddress(System.Net.IPAddress,System.Int32)">
            <summary>
            @see {@link #localAddress(SocketAddress)}
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Option``1(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOption{``0},``0)">
            <summary>
            Allow to specify a {@link ChannelOption} which is used for the {@link Channel} instances once they got
            created. Use a value of {@code null} to remove a previous set {@link ChannelOption}.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Validate">
            <summary>
            Validate all the parameters. Sub-classes may override this, but should
            call the super method in that case.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Clone">
            <summary>
            Returns a deep clone of this bootstrap which has the identical configuration.  This method is useful when making
            multiple {@link Channel}s with similar settings.  Please note that this method does not clone the
            {@link EventLoopGroup} deeply but shallowly, making the group a shared resource.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Register">
            <summary>
            Create a new {@link Channel} and register it with an {@link EventLoop}.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.BindAsync">
            <summary>
            Create a new {@link Channel} and bind it.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.BindAsync(System.Int32)">
            <summary>
            Create a new {@link Channel} and bind it.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.BindAsync(System.String,System.Int32)">
            <summary>
            Create a new {@link Channel} and bind it.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.BindAsync(System.Net.IPAddress,System.Int32)">
            <summary>
            Create a new {@link Channel} and bind it.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.BindAsync(System.Net.EndPoint)">
            <summary>
            Create a new {@link Channel} and bind it.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Handler(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            the {@link ChannelHandler} to use for serving the requests.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.AbstractBootstrap`2.Group">
            <summary>
            Return the configured {@link EventLoopGroup} or {@code null} if non is configured yet.
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.Bootstrap">
             <summary>
             A {@link Bootstrap} that makes it easy to bootstrap a {@link Channel} to use
             for clients.
            
             <p>The {@link #bind()} methods are useful in combination with connectionless transports such as datagram (UDP).
             For regular TCP connections, please use the provided {@link #connect()} methods.</p>
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.Bootstrap.Resolver(TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.INameResolver)">
            <summary>
            Sets the {@link NameResolver} which will resolve the address of the unresolved named address.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.Bootstrap.RemoteAddress(System.Net.EndPoint)">
            <summary>
            The {@link SocketAddress} to connect to once the {@link #connect()} method
            is called.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.Bootstrap.RemoteAddress(System.String,System.Int32)">
            <summary>
            @see {@link #remoteAddress(SocketAddress)}
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.Bootstrap.RemoteAddress(System.Net.IPAddress,System.Int32)">
            <summary>
            @see {@link #remoteAddress(SocketAddress)}
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync">
            <summary>
            Connect a {@link Channel} to the remote peer.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync(System.String,System.Int32)">
            <summary>
            Connect a {@link Channel} to the remote peer.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync(System.Net.IPAddress,System.Int32)">
            <summary>
            Connect a {@link Channel} to the remote peer.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync(System.Net.EndPoint)">
            <summary>
            Connect a {@link Channel} to the remote peer.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.Bootstrap.ConnectAsync(System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
            Connect a {@link Channel} to the remote peer.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.Bootstrap.DoResolveAndConnect(System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
            @see {@link #connect()}
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.Bootstrap.Clone(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IEventLoopGroup)">
            <summary>
            Returns a deep clone of this bootstrap which has the identical configuration except that it uses
            the given {@link EventLoopGroup}. This method is useful when making multiple {@link Channel}s with similar
            settings.
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.ServerBootstrap">
             <summary>
             {@link Bootstrap} sub-class which allows easy bootstrap of {@link ServerChannel}
            
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.ServerBootstrap.Group(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IEventLoopGroup)">
            <summary>
            Specify the {@link EventLoopGroup} which is used for the parent (acceptor) and the child (client).
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.ServerBootstrap.Group(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IEventLoopGroup,TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IEventLoopGroup)">
            <summary>
            Set the {@link EventLoopGroup} for the parent (acceptor) and the child (client). These
            {@link EventLoopGroup}'s are used to handle all the events and IO for {@link ServerChannel} and
            {@link Channel}'s.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.ServerBootstrap.ChildOption``1(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOption{``0},``0)">
            <summary>
            Allow to specify a {@link ChannelOption} which is used for the {@link Channel} instances once they get created
            (after the acceptor accepted the {@link Channel}). Use a value of {@code null} to remove a previous set
            {@link ChannelOption}.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.ServerBootstrap.ChildHandler(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandler)">
            <summary>
            Set the {@link ChannelHandler} which is used to serve the request for the {@link Channel}'s.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Bootstrapping.ServerBootstrap.ChildGroup">
            <summary>
            Return the configured {@link EventLoopGroup} which will be used for the child channels or {@code null}
            if non is configured yet.
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.AbstractChannel.strValActive">
            <summary> Cache for the string representation of this channel /// </summary>
        </member>
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.AbstractChannel.#ctor(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannel)”忽略有格式错误的 XML 注释 -->
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.AbstractChannel.Registered">
            <summary>
            Reset the stored remoteAddress
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.AbstractChannel.NewUnsafe">
            <summary>
            Create a new {@link AbstractUnsafe} instance which will be used for the life-time of the {@link Channel}
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.AbstractChannel.Equals(System.Object)">
            <summary>
            Returns {@code true} if and only if the specified object is identical
            with this channel (i.e: {@code this == o}).
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.AbstractChannel.ToString">
            <summary>
            Returns the {@link String} representation of this channel.  The returned
            string contains the {@linkplain #hashCode()} ID}, {@linkplain #localAddress() local address},
            and {@linkplain #remoteAddress() remote address} of this channel for
            easier identification.
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.AbstractChannel.AbstractUnsafe">
            <summary>
            {@link Unsafe} implementation which sub-classes must extend and use.
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.AbstractChannel.AbstractUnsafe.neverRegistered">
            <summary> true if the channel has never been registered, false otherwise /// </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.AbstractChannel.AbstractUnsafe.DeregisterAsync">
            <summary>
            This method must NEVER be called directly, but be executed as an
            extra task with a clean call stack instead. The reason for this
            is that this method calls {@link ChannelPipeline#fireChannelUnregistered()}
            directly, which might lead to an unfortunate nesting of independent inbound/outbound
            events. See the comments input {@link #invokeLater(Runnable)} for more details.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.AbstractChannel.IsCompatible(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IEventLoop)">
            <summary>
            Return {@code true} if the given {@link EventLoop} is compatible with this instance.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.AbstractChannel.DoRegister">
             <summary>
             Is called after the {@link Channel} is registered with its {@link EventLoop} as part of the register process.
            
             Sub-classes may override this method
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.AbstractChannel.DoBind(System.Net.EndPoint)">
            <summary>
            Bind the {@link Channel} to the {@link EndPoint}
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.AbstractChannel.DoDisconnect">
            <summary>
            Disconnect this {@link Channel} from its remote peer
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.AbstractChannel.DoClose">
            <summary>
            Close the {@link Channel}
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.AbstractChannel.DoDeregister">
             <summary>
             Deregister the {@link Channel} from its {@link EventLoop}.
            
             Sub-classes may override this method
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.AbstractChannel.DoBeginRead">
            <summary>
            Schedule a read operation.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.AbstractChannel.DoWrite(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOutboundBuffer)">
            <summary>
            Flush the content of the given buffer to the remote peer.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.AbstractChannel.FilterOutboundMessage(System.Object)">
            <summary>
            Invoked when a new message is added to a {@link ChannelOutboundBuffer} of this {@link AbstractChannel}, so that
            the {@link Channel} implementation converts the message to another. (e.g. heap buffer -> direct buffer)
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelInitializer`1”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelInitializer`1.InitChannel(`0)">
             <summary>
             This method will be called once the {@link Channel} was registered. After the method returns this instance
             will be removed from the {@link ChannelPipeline} of the {@link Channel}.
            
             @param channel            the {@link Channel} which was registered.
             @throws Exception    is thrown if an error occurs. In that case the {@link Channel} will be closed.
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOutboundBuffer.AddMessage(System.Object,System.Int32,TCBase.Distributed.TurboMQ.DotNetty.Common.Concurrency.TaskCompletionSource)">
            <summary>
            Add given message to this {@link ChannelOutboundBuffer}. The given {@link ChannelPromise} will be notified once
            the message was written.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOutboundBuffer.AddFlush">
            <summary>
            Add a flush to this {@link ChannelOutboundBuffer}. This means all previous added messages are marked as flushed
            and so you will be able to handle them.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOutboundBuffer.IncrementPendingOutboundBytes(System.Int64)">
            <summary>
            Increment the pending bytes which will be written at some point.
            This method is thread-safe!
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOutboundBuffer.DecrementPendingOutboundBytes(System.Int64)">
            <summary>
            Decrement the pending bytes which will be written at some point.
            This method is thread-safe!
            </summary>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOutboundBuffer.Current">
            <summary>
            Return the current message to write or {@code null} if nothing was flushed before and so is ready to be written.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOutboundBuffer.Progress(System.Int64)">
            <summary>
            Notify the {@link ChannelPromise} of the current message about writing progress.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOutboundBuffer.Remove">
            <summary>
            Will remove the current message, mark its {@link ChannelPromise} as success and return {@code true}. If no
            flushed message exists at the time this method is called it will return {@code false} to signal that no more
            messages are ready to be handled.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOutboundBuffer.Remove(System.Exception)">
            <summary>
            Will remove the current message, mark its {@link ChannelPromise} as failure using the given {@link Exception}
            and return {@code true}. If no   flushed message exists at the time this method is called it will return
            {@code false} to signal that no more messages are ready to be handled.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOutboundBuffer.RemoveBytes(System.Int64)">
            <summary>
            Removes the fully written entries and update the reader index of the partially written entry.
            This operation assumes all messages in this buffer is {@link ByteBuf}.
            </summary>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOutboundBuffer.IsWritable">
            <summary>
            Returns {@code true} if and only if {@linkplain #totalPendingWriteBytes() the total number of pending bytes} did
            not exceed the write watermark of the {@link Channel} and
            no {@linkplain #SetUserDefinedWritability(int, bool) user-defined writability flag} has been set to
            {@code false}.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOutboundBuffer.GetUserDefinedWritability(System.Int32)">
            <summary>
            Returns {@code true} if and only if the user-defined writability flag at the specified index is set to
            {@code true}.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOutboundBuffer.SetUserDefinedWritability(System.Int32,System.Boolean)">
            <summary>
            Sets a user-defined writability flag at the specified index.
            </summary>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOutboundBuffer.Count">
            <summary>
            Returns the number of flushed messages in this {@link ChannelOutboundBuffer}.
            </summary>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOutboundBuffer.IsEmpty">
            <summary>
            Returns {@code true} if there are flushed messages in this {@link ChannelOutboundBuffer} or {@code false}
            otherwise.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOutboundBuffer.IsFlushedEntry(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOutboundBuffer.Entry)">
            <summary>
            Call {@link IMessageProcessor#processMessage(Object)} for each flushed message
            in this {@link ChannelOutboundBuffer} until {@link IMessageProcessor#processMessage(Object)}
            returns {@code false} or there are no more flushed messages to process.
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.DefaultChannelConfiguration">
            <summary>
            Shared configuration for SocketAsyncChannel. Provides access to pre-configured resources like ByteBuf allocator and IO buffer pools
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.DefaultChannelPipeline.First">
             <summary>
             Waits for a future to finish.  If the task is interrupted, then the current thread will be interrupted.
             It is expected that the task performs any appropriate locking.
             <p>
             If the internal call throws a {@link Throwable}, but it is not an instance of {@link LogError} or
             {@link RuntimeException}, then it is wrapped inside a {@link ChannelPipelineException} and that is
             thrown instead.</p>
            
             @param future wait for this future
             @see Future#get()
             @throws LogError if the task threw this.
             @throws RuntimeException if the task threw this.
             @throws ChannelPipelineException with a {@link Throwable} as a cause, if the task threw another type of
                     {@link Throwable}.
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.DefaultChannelPipeline.ToString">
            <summary>
            Returns the {@link String} representation of this pipeline.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.DefaultChannelPipeline.Destroy">
             <summary>
             Removes all handlers from the pipeline one by one from tail (exclusive) to head (exclusive) to trigger
             handlerRemoved().
            
             Note that we traverse up the pipeline ({@link #destroyUp(AbstractChannelHandlerContext)})
             before traversing down ({@link #destroyDown(Thread, AbstractChannelHandlerContext)}) so that
             the handlers are removed after all events are handled.
            
             See: https://github.com/netty/netty/issues/3156
             </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.DefaultMessageSizeEstimator.Default">
            <summary>
            Return the default implementation which returns {@code -1} for unknown messages.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.DefaultMessageSizeEstimator.#ctor(System.Int32)">
             <summary>
             Create a new instance
            
             @param unknownSize       The size which is returned for unknown messages.
             </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.FixedRecvByteBufAllocator">
            <summary>
            The {@link RecvByteBufAllocator} that always yields the same buffer
            size prediction. This predictor ignores the feedback from the I/O thread.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.FixedRecvByteBufAllocator.#ctor(System.Int32)">
            <summary>
            Creates a new predictor that always returns the same prediction of
            the specified buffer size.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandler.ChannelRegistered(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            The {@link Channel} of the {@link ChannelHandlerContext} was registered with its {@link EventLoop}
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandler.ChannelUnregistered(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            The {@link Channel} of the {@link ChannelHandlerContext} was unregistered from its {@link EventLoop}
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandler.ChannelWritabilityChanged(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Gets called once the writable state of a {@link Channel} changed. You can check the state with
            {@link Channel#isWritable()}.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandler.BindAsync(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint)">
             <summary>
             Called once a bind operation is made.
            
             @param context           the {@link ChannelHandlerContext} for which the bind operation is made
             @param localAddress  the {@link java.net.SocketAddress} to which it should bound
             @param promise       the {@link ChannelPromise} to notify once the operation completes
             @throws Exception    thrown if an error accour
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandler.ConnectAsync(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint,System.Net.EndPoint)">
             <summary>
             Called once a connect operation is made.
            
             @param context               the {@link ChannelHandlerContext} for which the connect operation is made
             @param remoteAddress     the {@link SocketAddress} to which it should connect
             @param localAddress      the {@link SocketAddress} which is used as source on connect
             @param promise           the {@link ChannelPromise} to notify once the operation completes
             @throws Exception        thrown if an error accour
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandler.DisconnectAsync(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext)">
             <summary>
             Called once a disconnect operation is made.
            
             @param context               the {@link ChannelHandlerContext} for which the disconnect operation is made
             @param promise           the {@link ChannelPromise} to notify once the operation completes
             @throws Exception        thrown if an error accour
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelRegistered">
             <summary>
             A {@link Channel} was registered to its {@link EventLoop}.
            
             This will result in having the {@link ChannelHandler#channelRegistered(ChannelHandlerContext)} method
             called of the next {@link ChannelHandler} contained in the {@link ChannelPipeline} of the
             {@link Channel}.
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext.FireChannelUnregistered">
             <summary>
             A {@link Channel} was unregistered from its {@link EventLoop}.
            
             This will result in having the {@link ChannelHandler#channelUnregistered(ChannelHandlerContext)} method
             called of the next {@link ChannelHandler} contained in the {@link ChannelPipeline} of the
             {@link Channel}.
             </summary>
        </member>
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext.BindAsync(System.Net.EndPoint)”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext.ConnectAsync(System.Net.EndPoint)”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext.ConnectAsync(System.Net.EndPoint,System.Net.EndPoint)”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext.DisconnectAsync”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext.DeregisterAsync”忽略有格式错误的 XML 注释 -->
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerInvoker">
            <summary>
            Invokes the event handler methods of {@link ChannelHandler}.
            A user can specify a {@link ChannelHandlerInvoker} to implement a custom thread model unsupported by the default
            implementation. Note that the methods in this interface are not intended to be called by a user.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerInvoker.InvokeChannelRegistered(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Invokes {@link ChannelHandler#channelRegistered(ChannelHandlerContext)}. This method is not for a user
            but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
            {@link ChannelHandlerContext} instead.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerInvoker.InvokeChannelUnregistered(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Invokes {@link ChannelHandler#channelUnregistered(ChannelHandlerContext)}. This method is not for a user
            but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
            {@link ChannelHandlerContext} instead.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerInvoker.InvokeChannelActive(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Invokes {@link ChannelHandler#channelActive(ChannelHandlerContext)}. This method is not for a user
            but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
            {@link ChannelHandlerContext} instead.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerInvoker.InvokeChannelInactive(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Invokes {@link ChannelHandler#channelInactive(ChannelHandlerContext)}. This method is not for a user
            but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
            {@link ChannelHandlerContext} instead.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerInvoker.InvokeExceptionCaught(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext,System.Exception)">
            <summary>
            Invokes {@link ChannelHandler#exceptionCaught(ChannelHandlerContext, Throwable)}. This method is not for a user
            but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
            {@link ChannelHandlerContext} instead.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerInvoker.InvokeUserEventTriggered(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)">
            <summary>
            Invokes {@link ChannelHandler#userEventTriggered(ChannelHandlerContext, Object)}. This method is not for
            a user but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
            {@link ChannelHandlerContext} instead.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerInvoker.InvokeChannelRead(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)">
            <summary>
            Invokes {@link ChannelHandler#channelRead(ChannelHandlerContext, Object)}. This method is not for a user
            but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
            {@link ChannelHandlerContext} instead.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerInvoker.InvokeChannelReadComplete(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Invokes {@link ChannelHandler#channelReadComplete(ChannelHandlerContext)}. This method is not for a user
            but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
            {@link ChannelHandlerContext} instead.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerInvoker.InvokeChannelWritabilityChanged(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Invokes {@link ChannelHandler#channelWritabilityChanged(ChannelHandlerContext)}. This method is not for
            a user but for the internal {@link ChannelHandlerContext} implementation. To trigger an event, use the methods in
            {@link ChannelHandlerContext} instead.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerInvoker.InvokeBindAsync(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint)">
            <summary>
            Invokes {@link ChannelHandler#bind(ChannelHandlerContext, SocketAddress, ChannelPromise)}.
            This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
            To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerInvoker.InvokeConnectAsync(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext,System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
            Invokes
            {@link ChannelHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}.
            This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
            To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerInvoker.InvokeDisconnectAsync(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Invokes {@link ChannelHandler#disconnect(ChannelHandlerContext, ChannelPromise)}.
            This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
            To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerInvoker.InvokeCloseAsync(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Invokes {@link ChannelHandler#close(ChannelHandlerContext, ChannelPromise)}.
            This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
            To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerInvoker.InvokeDeregisterAsync(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Invokes {@link ChannelHandler#deregister(ChannelHandlerContext, ChannelPromise)}.
            This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
            To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerInvoker.InvokeRead(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Invokes {@link ChannelHandler#read(ChannelHandlerContext)}.
            This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
            To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerInvoker.InvokeWriteAsync(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)">
            <summary>
            Invokes {@link ChannelHandler#write(ChannelHandlerContext, Object, ChannelPromise)}.
            This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
            To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerInvoker.InvokeFlush(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Invokes {@link ChannelHandler#flush(ChannelHandlerContext)}.
            This method is not for a user but for the internal {@link ChannelHandlerContext} implementation.
            To trigger an event, use the methods in {@link ChannelHandlerContext} instead.
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.AddFirst(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandler)">
             <summary>
             Inserts a {@link ChannelHandler} at the first position of this pipeline.
            
             @param name     the name of the handler to insert first. {@code null} to let the name auto-generated.
             @param handler  the handler to insert first
            
             @throws IllegalArgumentException
                     if there's an entry with the same name already in the pipeline
             @throws NullPointerException
                     if the specified handler is {@code null}
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.AddLast(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandler)">
             <summary>
             Appends a {@link ChannelHandler} at the last position of this pipeline.
            
             @param name     the name of the handler to append. {@code null} to let the name auto-generated.
             @param handler  the handler to append
            
             @throws IllegalArgumentException
                     if there's an entry with the same name already in the pipeline
             @throws NullPointerException
                     if the specified handler is {@code null}
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.AddFirst(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandler[])">
             <summary>
             Inserts a {@link ChannelHandler}s at the first position of this pipeline.
            
             @param handlers  the handlers to insert first
            
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.AddLast(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandler[])">
             <summary>
             Inserts a {@link ChannelHandler}s at the last position of this pipeline.
            
             @param handlers  the handlers to insert last
            
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.Remove(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandler)">
             <summary>
             Removes the specified {@link ChannelHandler} from this pipeline.
            
             @param  handler          the {@link ChannelHandler} to remove
            
             @throws NoSuchElementException
                     if there's no such handler in this pipeline
             @throws NullPointerException
                     if the specified handler is {@code null}
             </summary>
        </member>
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.Remove``1”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.RemoveFirst">
             <summary>
             Removes the first {@link ChannelHandler} in this pipeline.
            
             @return the removed handler
            
             @throws NoSuchElementException
                     if this pipeline is empty
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.RemoveLast">
             <summary>
             Removes the last {@link ChannelHandler} in this pipeline.
            
             @return the removed handler
            
             @throws NoSuchElementException
                     if this pipeline is empty
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.Replace(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandler,TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandler)">
             <summary>
             Replaces the specified {@link ChannelHandler} with a new handler in this pipeline.
            
             @param  oldHandler    the {@link ChannelHandler} to be replaced
             @param  newName       the name under which the replacement should be added.
                                   {@code null} to use the same name with the handler being replaced.
             @param  newHandler    the {@link ChannelHandler} which is used as replacement
            
             @return itself
             @throws NoSuchElementException
                     if the specified old handler does not exist in this pipeline
             @throws IllegalArgumentException
                     if a handler with the specified new name already exists in this
                     pipeline, except for the handler to be replaced
             @throws NullPointerException
                     if the specified old handler or new handler is {@code null}
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.Replace``1(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandler)">
             <summary>
             Replaces the {@link ChannelHandler} of the specified type with a new handler in this pipeline.
            
             @param  oldHandlerType   the type of the handler to be removed
             @param  newName          the name under which the replacement should be added.
                                      {@code null} to use the same name with the handler being replaced.
             @param  newHandler       the {@link ChannelHandler} which is used as replacement
            
             @return the removed handler
            
             @throws NoSuchElementException
                     if the handler of the specified old handler type does not exist
                     in this pipeline
             @throws IllegalArgumentException
                     if a handler with the specified new name already exists in this
                     pipeline, except for the handler to be replaced
             @throws NullPointerException
                     if the specified old handler or new handler is {@code null}
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.First">
             <summary>
             Returns the first {@link ChannelHandler} in this pipeline.
            
             @return the first handler.  {@code null} if this pipeline is empty.
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.FirstContext">
             <summary>
             Returns the context of the first {@link ChannelHandler} in this pipeline.
            
             @return the context of the first handler.  {@code null} if this pipeline is empty.
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.Last">
             <summary>
             Returns the last {@link ChannelHandler} in this pipeline.
            
             @return the last handler.  {@code null} if this pipeline is empty.
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.LastContext">
             <summary>
             Returns the context of the last {@link ChannelHandler} in this pipeline.
            
             @return the context of the last handler.  {@code null} if this pipeline is empty.
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.Get``1">
             <summary>
             Returns the {@link ChannelHandler} of the specified type in this
             pipeline.
            
             @return the handler of the specified handler type.
                     {@code null} if there's no such handler in this pipeline.
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.Context(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelHandler)">
             <summary>
             Returns the context object of the specified {@link ChannelHandler} in
             this pipeline.
            
             @return the context object of the specified handler.
                     {@code null} if there's no such handler in this pipeline.
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.Context``1">
             <summary>
             Returns the context object of the {@link ChannelHandler} of the
             specified type in this pipeline.
            
             @return the context object of the handler of the specified type.
                     {@code null} if there's no such handler in this pipeline.
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.Channel">
             <summary>
             Returns the {@link Channel} that this pipeline is attached to.
            
             @return the channel. {@code null} if this pipeline is not attached yet.
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.FireChannelRegistered">
             <summary>
             A {@link Channel} is active now, which means it is connected.
            
             This will result in having the  {@link ChannelHandler#channelActive(ChannelHandlerContext)} method
             called of the next  {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
             {@link Channel}.
             </summary>
             <summary>
             A {@link Channel} was registered to its {@link EventLoop}.
            
             This will result in having the  {@link ChannelHandler#channelRegistered(ChannelHandlerContext)} method
             called of the next  {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
             {@link Channel}.
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.FireChannelUnregistered">
             <summary>
             A {@link Channel} was unregistered from its {@link EventLoop}.
            
             This will result in having the  {@link ChannelHandler#channelUnregistered(ChannelHandlerContext)} method
             called of the next  {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
             {@link Channel}.
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.FireChannelActive">
             <summary>
             A {@link Channel} is active now, which means it is connected.
            
             This will result in having the  {@link ChannelHandler#channelActive(ChannelHandlerContext)} method
             called of the next  {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
             {@link Channel}.
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.FireChannelInactive">
             <summary>
             A {@link Channel} is inactive now, which means it is closed.
            
             This will result in having the  {@link ChannelHandler#channelInactive(ChannelHandlerContext)} method
             called of the next  {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
             {@link Channel}.
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.FireExceptionCaught(System.Exception)">
             <summary>
             A {@link Channel} received an {@link Throwable} in one of its inbound operations.
            
             This will result in having the  {@link ChannelHandler#exceptionCaught(ChannelHandlerContext, Throwable)}
             method  called of the next  {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
             {@link Channel}.
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.FireUserEventTriggered(System.Object)">
             <summary>
             A {@link Channel} received an user defined event.
            
             This will result in having the  {@link ChannelHandler#userEventTriggered(ChannelHandlerContext, Object)}
             method  called of the next  {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
             {@link Channel}.
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.FireChannelRead(System.Object)">
             <summary>
             A {@link Channel} received a message.
            
             This will result in having the {@link ChannelHandler#channelRead(ChannelHandlerContext, Object)}
             method  called of the next {@link ChannelHandler} contained in the  {@link ChannelPipeline} of the
             {@link Channel}.
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.FireChannelWritabilityChanged">
            <summary>
            Triggers an {@link ChannelHandler#channelWritabilityChanged(ChannelHandlerContext)}
            event to the next {@link ChannelHandler} in the {@link ChannelPipeline}.
            </summary>
        </member>
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.BindAsync(System.Net.EndPoint)”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.ConnectAsync(System.Net.EndPoint)”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.ConnectAsync(System.Net.EndPoint,System.Net.EndPoint)”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.DisconnectAsync”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.CloseAsync”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.DeregisterAsync”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.Read”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.WriteAsync(System.Object)">
            <summary>
            Request to write a message via this {@link ChannelPipeline}.
            This method will not request to actual flush, so be sure to call {@link #flush()}
            once you want to request to flush all pending data to the actual transport.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.Flush">
            <summary>
            Request to flush all pending messages.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannelPipeline.WriteAndFlushAsync(System.Object)">
            <summary>
            Shortcut for call {@link #write(Object)} and {@link #flush()}.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IMessageSizeEstimator.NewHandle">
            <summary>
            Creates a new handle. The handle provides the actual operations.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IMessageSizeEstimatorHandle.Size(System.Object)">
             <summary>
             Calculate the size of the given message.
            
             @param msg       The message for which the size should be calculated
             @return size     The size in bytes. The returned size must be >= 0
             </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IRecvByteBufAllocator">
            <summary>
            Allocates a new receive buffer whose capacity is probably large enough to read all inbound data and small enough
            not to waste its space.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IRecvByteBufAllocator.NewHandle">
            <summary>
            Creates a new handle.  The handle provides the actual operations and keeps the internal information which is
            required for predicting an optimal buffer capacity.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.Allocate(TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBufferAllocator)">
            <summary>
            Creates a new receive buffer whose capacity is probably large enough to read all inbound data and small
            enough not to waste its space.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.Guess">
            <summary>
            Similar to {@link #allocate(ByteBufAllocator)} except that it does not allocate anything but just tells the
            capacity.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IRecvByteBufAllocatorHandle.Record(System.Int32)">
             <summary>
             Records the the actual number of read bytes in the previous read operation so that the allocator allocates
             the buffer with potentially more correct capacity.
            
             @param actualReadBytes the actual number of read bytes in the previous read operation
             </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IServerChannel">
            <summary>
            A {@link Channel} that accepts an incoming connection attempt and creates
            its child {@link Channel}s by accepting them.  {@link ServerSocketChannel} is
            a good example.
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.AbstractSocketByteChannel">
            <summary>
            {@link AbstractNioChannel} base class for {@link Channel}s that operate on bytes.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.AbstractSocketByteChannel.#ctor(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannel,System.Net.Sockets.Socket)">
             <summary>
             Create a new instance
            
             @param parent            the parent {@link Channel} by which this instance was created. May be {@code null}
             @param ch                the underlying {@link SelectableChannel} on which it operates
             </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.AbstractSocketByteChannel.DoReadBytes(TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer)">
            <summary>
            Read bytes into the given {@link ByteBuf} and return the amount.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.AbstractSocketByteChannel.DoWriteBytes(TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer)">
            <summary>
            Write bytes form the given {@link ByteBuf} to the underlying {@link java.nio.channels.Channel}.
            @param buf           the {@link ByteBuf} from which the bytes should be written
            @return amount       the amount of written bytes
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.AbstractSocketChannel.OnIoCompleted(System.Object,System.Net.Sockets.SocketAsyncEventArgs)">
            <remarks>PORT NOTE: matches behavior of NioEventLoop.processSelectedKey</remarks>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.AbstractSocketChannel.ISocketChannelUnsafe.FinishConnect(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.SocketChannelAsyncOperation)">
            <summary>
            Finish connect
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.AbstractSocketChannel.ISocketChannelUnsafe.FinishRead(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.SocketChannelAsyncOperation)">
            <summary>
            Read from underlying {@link SelectableChannel}
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.AbstractSocketChannel.DoConnect(System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
             Connect to the remote peer
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.AbstractSocketChannel.DoFinishConnect(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.SocketChannelAsyncOperation)">
            <summary>
            Finish the connect
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.AbstractSocketMessageChannel">
            <summary>
            {@link AbstractNioChannel} base class for {@link Channel}s that operate on messages.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.AbstractSocketMessageChannel.#ctor(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannel,System.Net.Sockets.Socket)">
            <summary>
            @see {@link AbstractNioChannel#AbstractNioChannel(Channel, SelectableChannel, int)}
            </summary>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.AbstractSocketMessageChannel.ContinueOnWriteError">
            <summary>
            Returns {@code true} if we should continue the write loop on a write error.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.AbstractSocketMessageChannel.DoReadMessages(System.Collections.Generic.List{System.Object})">
            <summary>
            Read messages into the given array and return the amount which was read.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.AbstractSocketMessageChannel.DoWriteMessage(System.Object,TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.ChannelOutboundBuffer)">
             <summary>
             Write a message to the underlying {@link java.nio.channels.Channel}.
            
             @return {@code true} if and only if the message has been written
             </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.ChannelInputShutdownEvent">
            <summary>
            Special event which will be fired and passed to the
            {@link ChannelHandler#userEventTriggered(ChannelHandlerContext, Object)} methods once the input of
            a {@link SocketChannel} was shutdown and the {@link SocketChannelConfig#isAllowHalfClosure()} method returns
            {@code true}.
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.ChannelInputShutdownEvent.Instance">
            <summary>
            Instance to use
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.DefaultServerSocketChannelConfig">
            <summary>
            The default {@link ServerSocketChannelConfig} implementation.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.DefaultServerSocketChannelConfig.#ctor(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.IServerSocketChannel,System.Net.Sockets.Socket)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.DefaultSocketChannelConfiguration">
            <summary>
            The default {@link SocketChannelConfig} implementation.
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.IServerSocketChannel">
            <summary>
            A TCP/IP {@link ServerChannel} which accepts incoming TCP/IP connections.
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.TcpServerSocketChannel">
            <summary>
            A {@link io.netty.channel.socket.ServerSocketChannel} implementation which uses
            NIO selector based implementation to accept new connections.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.TcpServerSocketChannel.#ctor">
            <summary>
            Create a new instance
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.TcpServerSocketChannel.#ctor(System.Net.Sockets.AddressFamily)">
            <summary>
            Create a new instance
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.TcpServerSocketChannel.#ctor(System.Net.Sockets.Socket)">
            <summary>
            Create a new instance using the given {@link Socket}.
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.TcpSocketChannel">
            <summary>
             {@link io.netty.channel.socket.SocketChannel} which uses NIO selector based implementation.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.TcpSocketChannel.#ctor">
            <summary>
             Create a new instance
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.TcpSocketChannel.#ctor(System.Net.Sockets.AddressFamily)">
            <summary>
             Create a new instance
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.TcpSocketChannel.#ctor(System.Net.Sockets.Socket)">
            <summary>
             Create a new instance using the given {@link SocketChannel}.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Sockets.TcpSocketChannel.#ctor(TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.IChannel,System.Net.Sockets.Socket)">
            <summary>
             Create a new instance
            
             @param parent    the {@link Channel} which created this instance or {@code null} if it was created by the user
             @param socket    the {@link SocketChannel} which will be used
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Util.SafeSetSuccess(TCBase.Distributed.TurboMQ.DotNetty.Common.Concurrency.TaskCompletionSource)">
            <summary>
            Marks the specified {@code promise} as success.  If the {@code promise} is done already, log a message.
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.DotNetty.Transport.Channels.Util.SafeSetFailure(TCBase.Distributed.TurboMQ.DotNetty.Common.Concurrency.TaskCompletionSource,System.Exception)">
            <summary>
            Marks the specified {@code promise} as failure.  If the {@code promise} is done already, log a message.
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Admin.MQAdminExtInner”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.ClientConfig”忽略有格式错误的 XML 注释 -->
        <member name="F:TCBase.Distributed.TurboMQ.Client.ClientConfig.pollNameServerInteval">
            <summary>
            Pulling topic information interval from the named server
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.ClientConfig.heartbeatBrokerInterval">
            <summary>
            Heartbeat interval in microseconds with message broker
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.ClientConfig.persistConsumerOffsetInterval">
            <summary>
            Offset persistent interval for consumer
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.AllocateMessageQueueStrategy”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.AllocateMessageQueueStrategy.Allocate(System.String,System.String,System.Collections.Generic.IList{TCBase.Distributed.TurboMQ.Common.Message.MessageQueue},System.Collections.Generic.IList{System.String})">
            <summary>
            Allocating by consumer id
            </summary>
            <param name="consumerGroup"> current consumer group </param>
            <param name="currentCID">    current consumer id </param>
            <param name="mqAll">         message queue set in current topic </param>
            <param name="cidAll">        consumer set in current consumer group
            @return </param>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.Client.Consumer.AllocateMessageQueueStrategy.Name">
            <summary>
            Algorithm name
            
            @return
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPullConsumer”忽略有格式错误的 XML 注释 -->
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPullConsumer.consumerGroup">
            <summary>
            Do the same thing for the same Group, the application must be set,and guarantee Globally unique
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPullConsumer.brokerSuspendMaxTimeMillis">
            <summary>
            Long polling mode, the Consumer connection max suspend time, it is not recommended to modify
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPullConsumer.consumerTimeoutMillisWhenSuspend">
            <summary>
            Long polling mode, the Consumer connection timeout(must greater than brokerSuspendMaxTimeMillis), it is not recommended to modify
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPullConsumer.consumerPullTimeoutMillis">
            <summary>
            The socket timeout in milliseconds
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPullConsumer.messageModel">
            <summary>
            Consumption pattern,default is clustering
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPullConsumer.messageQueueListener">
            <summary>
            Message queue listener
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPullConsumer.offsetStore">
            <summary>
            Offset Storage
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPullConsumer.registerTopics">
            <summary>
            Topic set you want to register
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPullConsumer.allocateMessageQueueStrategy">
            <summary>
            Queue allocation algorithm
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPullConsumer.unitMode">
            <summary>
            Whether the unit of subscription group
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer”忽略有格式错误的 XML 注释 -->
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer.consumerGroup">
            <summary>
            Do the same thing for the same Group, the application must be set,and
            guarantee Globally unique
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer.messageModel">
            <summary>
            Consumption pattern,default is clustering
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer.consumeFromWhere">
            <summary>
            Consumption offset
            </summary>
        </member>
        <!-- 对于成员“F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer.consumeTimestamp”忽略有格式错误的 XML 注释 -->
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer.allocateMessageQueueStrategy">
            <summary>
            Queue allocation algorithm
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer.subscription">
            <summary>
            Subscription relationship
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer.messageListener">
            <summary>
            Message listener
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer.offsetStore">
            <summary>
            Offset Storage
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer.consumeThreadMin">
            <summary>
            Minimum consumer thread number
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer.consumeThreadMax">
            <summary>
            Max consumer thread number
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer.adjustThreadPoolNumsThreshold">
            <summary>
            Threshold for dynamic adjustment of the number of thread pool
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer.consumeConcurrentlyMaxSpan">
            <summary>
            Concurrently max span offset.it has no effect on sequential consumption
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer.pullThresholdForQueue">
            <summary>
            Flow control threshold
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer.pullInterval">
            <summary>
            Message pull Interval
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer.consumeMessageBatchMaxSize">
            <summary>
            Batch consumption size
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer.pullBatchSize">
            <summary>
            Batch pull size
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer.postSubscriptionWhenPull">
            <summary>
            Whether update subscription relationship when every pull
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer.unitMode">
            <summary>
            Whether the unit of subscription group
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.DefaultMQPushConsumer.Start">
            <summary>
            启动消费者
            </summary>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException">客户端异常</exception>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.Listener.ConsumeConcurrentlyContext”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“F:TCBase.Distributed.TurboMQ.Client.Consumer.Listener.ConsumeConcurrentlyContext.delayLevelWhenNextConsume”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.Listener.ConsumeConcurrentlyStatus”忽略有格式错误的 XML 注释 -->
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.Listener.ConsumeConcurrentlyStatus.CONSUME_SUCCESS">
            <summary>
            Success consumption
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.Listener.ConsumeConcurrentlyStatus.RECONSUME_LATER">
            <summary>
            Failure consumption,later try to consume
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.Listener.ConsumeOrderlyContext”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.Listener.ConsumeOrderlyStatus”忽略有格式错误的 XML 注释 -->
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.Listener.ConsumeOrderlyStatus.SUCCESS">
            <summary>
            Success consumption
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.Listener.ConsumeOrderlyStatus.ROLLBACK">
            <summary>
            Rollback consumption(only for binlog consumption)
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.Listener.ConsumeOrderlyStatus.COMMIT">
            <summary>
            Commit offset(only for binlog consumption)
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.Listener.ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT">
            <summary>
            Suspend current queue a moment
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.Listener.MessageListener”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.Listener.MessageListenerConcurrently”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.Client.Consumer.Listener.MessageListenerConcurrently.ConsumeMessage(System.Collections.Generic.IList{TCBase.Distributed.TurboMQ.Common.Message.MessageExt},TCBase.Distributed.TurboMQ.Client.Consumer.Listener.ConsumeConcurrentlyContext)”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.Listener.MessageListenerOrderly”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.Client.Consumer.Listener.MessageListenerOrderly.ConsumeMessage(System.Collections.Generic.IList{TCBase.Distributed.TurboMQ.Common.Message.MessageExt},TCBase.Distributed.TurboMQ.Client.Consumer.Listener.ConsumeOrderlyContext)”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.MessageQueueListener”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MessageQueueListener.MessageQueueChanged(System.String,System.Collections.Generic.ISet{TCBase.Distributed.TurboMQ.Common.Message.MessageQueue},System.Collections.Generic.ISet{TCBase.Distributed.TurboMQ.Common.Message.MessageQueue})">
            <param name="topic">     message topic </param>
            <param name="mqAll">     all queues in this message topic </param>
            <param name="mqDivided"> collection of queues,assigned to the current consumer </param>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.MQConsumer”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQConsumer.SendMessageBack(TCBase.Distributed.TurboMQ.Common.Message.MessageExt,System.Int32)">
            <summary>
            If consuming failure,message will be send back to the brokers,and delay consuming some time
            </summary>
            <param name="msg"> </param>
            <param name="delayLevel"> </param>
            <exception cref="!:InterruptedException"> </exception>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQBrokerException"> </exception>
            <exception cref="T:TCBase.Distributed.TurboMQ.Remoting.Exceptions.RemotingException"> </exception>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQConsumer.SendMessageBack(TCBase.Distributed.TurboMQ.Common.Message.MessageExt,System.Int32,System.String)">
            <summary>
            If consuming failure,message will be send back to the broker,and delay consuming some time
            </summary>
            <param name="msg"> </param>
            <param name="delayLevel"> </param>
            <param name="brokerName"> </param>
            <exception cref="T:TCBase.Distributed.TurboMQ.Remoting.Exceptions.RemotingException"> </exception>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQBrokerException"> </exception>
            <exception cref="!:InterruptedException"> </exception>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQConsumer.FetchSubscribeMessageQueues(System.String)">
            <summary>
            Fetch message queues from consumer cache according to the topic
            </summary>
            <param name="topic"> message topic </param>
            <returns> queue set </returns>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.MQPullConsumer”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPullConsumer.Start">
            <summary>
            Start the consumer
            </summary>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPullConsumer.Shutdown">
            <summary>
            Shutdown the consumer
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPullConsumer.RegisterMessageQueueListener(System.String,TCBase.Distributed.TurboMQ.Client.Consumer.MessageQueueListener)">
            <summary>
            Register the message queue listener
            </summary>
            <param name="topic"> </param>
            <param name="listener"> </param>
        </member>
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPullConsumer.Pull(TCBase.Distributed.TurboMQ.Common.Message.MessageQueue,System.String,System.Int64,System.Int32)”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPullConsumer.Pull(TCBase.Distributed.TurboMQ.Common.Message.MessageQueue,System.String,System.Int64,System.Int32,System.Int64)">
            <summary>
            Pulling the messages in the specified timeout
            </summary>
            <param name="mq"> </param>
            <param name="subExpression"> </param>
            <param name="offset"> </param>
            <param name="maxNums"> </param>
            <param name="timeout">
            @return </param>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
            <exception cref="T:TCBase.Distributed.TurboMQ.Remoting.Exceptions.RemotingException"> </exception>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQBrokerException"> </exception>
            <exception cref="!:InterruptedException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPullConsumer.Pull(TCBase.Distributed.TurboMQ.Common.Message.MessageQueue,System.String,System.Int64,System.Int32,TCBase.Distributed.TurboMQ.Client.Consumer.PullCallback)">
            <summary>
            Pulling the messages in a async. way
            </summary>
            <param name="mq"> </param>
            <param name="subExpression"> </param>
            <param name="offset"> </param>
            <param name="maxNums"> </param>
            <param name="pullCallback"> </param>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
            <exception cref="T:TCBase.Distributed.TurboMQ.Remoting.Exceptions.RemotingException"> </exception>
            <exception cref="!:InterruptedException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPullConsumer.Pull(TCBase.Distributed.TurboMQ.Common.Message.MessageQueue,System.String,System.Int64,System.Int32,TCBase.Distributed.TurboMQ.Client.Consumer.PullCallback,System.Int64)">
            <summary>
            Pulling the messages in a async. way
            </summary>
            <param name="mq"> </param>
            <param name="subExpression"> </param>
            <param name="offset"> </param>
            <param name="maxNums"> </param>
            <param name="pullCallback"> </param>
            <param name="timeout"> </param>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
            <exception cref="T:TCBase.Distributed.TurboMQ.Remoting.Exceptions.RemotingException"> </exception>
            <exception cref="!:InterruptedException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPullConsumer.PullBlockIfNotFound(TCBase.Distributed.TurboMQ.Common.Message.MessageQueue,System.String,System.Int64,System.Int32)">
            <summary>
            Pulling the messages,if no message arrival,blocking some time
            </summary>
            <param name="mq"> </param>
            <param name="subExpression"> </param>
            <param name="offset"> </param>
            <param name="maxNums">
            @return </param>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
            <exception cref="T:TCBase.Distributed.TurboMQ.Remoting.Exceptions.RemotingException"> </exception>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQBrokerException"> </exception>
            <exception cref="!:InterruptedException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPullConsumer.PullBlockIfNotFound(TCBase.Distributed.TurboMQ.Common.Message.MessageQueue,System.String,System.Int64,System.Int32,TCBase.Distributed.TurboMQ.Client.Consumer.PullCallback)">
            <summary>
            Pulling the messages through callback function,if no message arrival,blocking.
            </summary>
            <param name="mq"> </param>
            <param name="subExpression"> </param>
            <param name="offset"> </param>
            <param name="maxNums"> </param>
            <param name="pullCallback"> </param>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
            <exception cref="T:TCBase.Distributed.TurboMQ.Remoting.Exceptions.RemotingException"> </exception>
            <exception cref="!:InterruptedException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPullConsumer.UpdateConsumeOffset(TCBase.Distributed.TurboMQ.Common.Message.MessageQueue,System.Int64)">
            <summary>
            Update the offset
            </summary>
            <param name="mq"> </param>
            <param name="offset"> </param>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPullConsumer.FetchConsumeOffset(TCBase.Distributed.TurboMQ.Common.Message.MessageQueue,System.Boolean)">
            <summary>
            Fetch the offset
            </summary>
            <param name="mq"> </param>
            <param name="fromStore">
            @return </param>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPullConsumer.FetchMessageQueuesInBalance(System.String)">
            <summary>
            Fetch the message queues according to the topic
            </summary>
            <param name="topic"> message topic </param>
            <returns> message queue set </returns>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
        </member>
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPullConsumer.SendMessageBack(TCBase.Distributed.TurboMQ.Common.Message.MessageExt,System.Int32,System.String,System.String)”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.MQPushConsumer”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPushConsumer.Start">
            <summary>
            Start the consumer
            </summary>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPushConsumer.Shutdown">
            <summary>
            Shutdown the consumer
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPushConsumer.RegisterMessageListener(TCBase.Distributed.TurboMQ.Client.Consumer.Listener.MessageListenerConcurrently)">
            <summary>
            Register the message listener
            </summary>
            <param name="messageListener"> </param>
        </member>
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPushConsumer.Subscribe(System.String,System.String)”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPushConsumer.Subscribe(System.String,System.String,System.String)">
            <summary>
            Subscribe some topic
            </summary>
            <param name="topic"> </param>
            <param name="fullClassName">
                       full class name，must extend
                       TCMSDotNetRocketMQ.common.filter. MessageFilter </param>
            <param name="filterClassSource">
                       class source code，used UTF-8 file encoding,must be responsible
                       for your code safety </param>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPushConsumer.Unsubscribe(System.String)">
            <summary>
            Unsubscribe consumption some topic
            </summary>
            <param name="topic">
                       message topic </param>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPushConsumer.UpdateCorePoolSize(System.Int32)">
            <summary>
            Update the consumer thread pool size Dynamically
            </summary>
            <param name="corePoolSize"> </param>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPushConsumer.Suspend">
            <summary>
            Suspend the consumption
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.MQPushConsumer.Resume">
            <summary>
            Resume the consumption
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.PullCallback”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.PullResult”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.PullStatus”忽略有格式错误的 XML 注释 -->
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.PullStatus.FOUND">
            <summary>
            Founded
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.PullStatus.NO_NEW_MSG">
            <summary>
            No new message can be pull
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.PullStatus.NO_MATCHED_MSG">
            <summary>
            Filtering results can not match
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.PullStatus.OFFSET_ILLEGAL">
            <summary>
            Illegal offset，may be too big or too small
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.Rebalance.AllocateMessageQueueAveragely”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.Rebalance.AllocateMessageQueueAveragelyByCircle”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.Rebalance.AllocateMessageQueueByConfig”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.Rebalance.AllocateMessageQueueByMachineRoom”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.Store.LocalFileOffsetStore”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.Store.OffsetSerializeWrapper”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.Store.OffsetStore”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.Store.OffsetStore.Load">
            <summary>
            Load
            </summary>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.Store.OffsetStore.UpdateOffset(TCBase.Distributed.TurboMQ.Common.Message.MessageQueue,System.Int64,System.Boolean)">
            <summary>
            Update the offset,store it in memory
            </summary>
            <param name="mq"> </param>
            <param name="offset"> </param>
            <param name="increaseOnly"> </param>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.Store.OffsetStore.ReadOffset(TCBase.Distributed.TurboMQ.Common.Message.MessageQueue,TCBase.Distributed.TurboMQ.Client.Consumer.Store.ReadOffsetType)">
            <summary>
            Get offset from local storage
            </summary>
            <param name="mq"> </param>
            <param name="type">
            @return </param>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.Store.OffsetStore.PersistAll(System.Collections.Generic.ISet{TCBase.Distributed.TurboMQ.Common.Message.MessageQueue})">
            <summary>
            Persist all offsets,may be in local storage or remote name server
            </summary>
            <param name="mqs"> </param>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.Store.OffsetStore.Persist(TCBase.Distributed.TurboMQ.Common.Message.MessageQueue)">
            <summary>
            Persist the offset,may be in local storage or remote name server
            </summary>
            <param name="mq"> </param>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.Store.OffsetStore.RemoveOffset(TCBase.Distributed.TurboMQ.Common.Message.MessageQueue)">
            <summary>
            Remove offset
            </summary>
            <param name="mq"> </param>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.Store.OffsetStore.CloneOffsetTable(System.String)">
            <param name="topic">
            @return </param>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.Store.ReadOffsetType.READ_FROM_MEMORY">
            <summary>
            From memory
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.Store.ReadOffsetType.READ_FROM_STORE">
            <summary>
            From storage
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Consumer.Store.ReadOffsetType.MEMORY_FIRST_THEN_STORE">
            <summary>
            From memory,then from storage
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Consumer.Store.RemoteBrokerOffsetStore”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Client.Consumer.Store.RemoteBrokerOffsetStore.UpdateConsumeOffsetToBroker(TCBase.Distributed.TurboMQ.Common.Message.MessageQueue,System.Int64)">
            <summary>
            Update the Consumer Offset, once the Master is off, updated to Slave,
            here need to be optimized.
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQBrokerException”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Hook.CheckForbiddenContext”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Hook.CheckForbiddenHook”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Hook.FilterMessageContext”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Hook.FilterMessageHook”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.CommunicationMode”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Consumer.ConsumeMessageConcurrentlyService”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Consumer.ConsumeMessageOrderlyService”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Consumer.ConsumeMessageService”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Consumer.DefaultMQPullConsumerImpl”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Consumer.DefaultMQPushConsumerImpl”忽略有格式错误的 XML 注释 -->
        <member name="F:TCBase.Distributed.TurboMQ.Client.Impl.Consumer.DefaultMQPushConsumerImpl.PullTimeDelayMillsWhenException">
            <summary>
            Delay some time when exception occur
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Impl.Consumer.DefaultMQPushConsumerImpl.PullTimeDelayMillsWhenFlowControl">
            <summary>
            Flow control interval
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Client.Impl.Consumer.DefaultMQPushConsumerImpl.PullTimeDelayMillsWhenSuspend">
            <summary>
            Delay some time when suspend pull service
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Consumer.MessageQueueLock”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Consumer.MQConsumerInner”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Consumer.ProcessQueue”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Consumer.PullAPIWrapper”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Consumer.PullMessageService”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Consumer.PullRequest”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Consumer.PullResultExt”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Consumer.RebalanceImpl”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Consumer.RebalancePullImpl”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Consumer.RebalancePushImpl”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Consumer.RebalanceService”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Factory.MQClientInstance”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Client.Impl.Factory.MQClientInstance.CleanOfflineBroker">
            <summary>
            Remove offline broker
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.FindBrokerResult”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.MQAdminImpl”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.MQClientAPIImpl”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.MQClientManager”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Producer.DefaultMQProducerImpl”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Client.Impl.Producer.DefaultMQProducerImpl.Send(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Client.Producer.SendCallback)">
            <summary>
            DEFAULT ASYNC -------------------------------------------------------
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Impl.Producer.DefaultMQProducerImpl.SendOneway(TCBase.Distributed.TurboMQ.Common.Message.Message)">
            <summary>
            DEFAULT ONEWAY -------------------------------------------------------
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Impl.Producer.DefaultMQProducerImpl.Send(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Common.Message.MessageQueue)">
            <summary>
            KERNEL SYNC -------------------------------------------------------
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Impl.Producer.DefaultMQProducerImpl.Send(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Common.Message.MessageQueue,TCBase.Distributed.TurboMQ.Client.Producer.SendCallback)">
            <summary>
            KERNEL ASYNC -------------------------------------------------------
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Impl.Producer.DefaultMQProducerImpl.SendOneway(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Common.Message.MessageQueue)">
            <summary>
            KERNEL ONEWAY -------------------------------------------------------
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Impl.Producer.DefaultMQProducerImpl.Send(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Client.Producer.MessageQueueSelector,System.Object)">
            <summary>
            SELECT SYNC -------------------------------------------------------
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Impl.Producer.DefaultMQProducerImpl.Send(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Client.Producer.MessageQueueSelector,System.Object,TCBase.Distributed.TurboMQ.Client.Producer.SendCallback)">
            <summary>
            SELECT ASYNC -------------------------------------------------------
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Impl.Producer.DefaultMQProducerImpl.SendOneway(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Client.Producer.MessageQueueSelector,System.Object)">
            <summary>
            SELECT ONEWAY -------------------------------------------------------
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Impl.Producer.DefaultMQProducerImpl.Send(TCBase.Distributed.TurboMQ.Common.Message.Message)">
            <summary>
            DEFAULT SYNC -------------------------------------------------------
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Producer.MQProducerInner”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Impl.Producer.TopicPublishInfo”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Log.ClientLogger”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.MQAdmin”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Client.MQAdmin.CreateTopic(System.String,System.String,System.Int32)">
            <summary>
            Creates an topic
            </summary>
            <param name="key">      accesskey </param>
            <param name="newTopic"> topic name </param>
            <param name="queueNum"> topic's queue number </param>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.MQAdmin.CreateTopic(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Creates an topic
            </summary>
            <param name="key">          accesskey </param>
            <param name="newTopic">     topic name </param>
            <param name="queueNum">     topic's queue number </param>
            <param name="topicSysFlag"> topic system flag </param>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
        </member>
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.Client.MQAdmin.SearchOffset(TCBase.Distributed.TurboMQ.Common.Message.MessageQueue,System.Int64)”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Client.MQAdmin.MaxOffset(TCBase.Distributed.TurboMQ.Common.Message.MessageQueue)">
            <summary>
            Gets the max offset
            </summary>
            <param name="mq"> Instance of MessageQueue </param>
            <returns> the max offset </returns>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.MQAdmin.MinOffset(TCBase.Distributed.TurboMQ.Common.Message.MessageQueue)">
            <summary>
            Gets the minimum offset
            </summary>
            <param name="mq"> Instance of MessageQueue </param>
            <returns> the minimum offset </returns>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.MQAdmin.EarliestMsgStoreTime(TCBase.Distributed.TurboMQ.Common.Message.MessageQueue)">
            <summary>
            Gets the earliest stored message time
            </summary>
            <param name="mq"> Instance of MessageQueue </param>
            <returns> the time in microseconds </returns>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.MQAdmin.ViewMessage(System.String)">
            <summary>
            Query message according tto message id
            </summary>
            <param name="msgId"> message id </param>
            <returns> message </returns>
            <exception cref="!:InterruptedException"> </exception>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQBrokerException"> </exception>
            <exception cref="T:TCBase.Distributed.TurboMQ.Remoting.Exceptions.RemotingException"> </exception>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.MQAdmin.QueryMessage(System.String,System.String,System.Int32,System.Int64,System.Int64)">
            <summary>
            Query messages
            </summary>
            <param name="topic">  message topic </param>
            <param name="key">    message key index word </param>
            <param name="maxNum"> max message number </param>
            <param name="begin">  from when </param>
            <param name="end">    to when </param>
            <returns> Instance of QueryResult </returns>
            <exception cref="T:TCBase.Distributed.TurboMQ.Client.Exceptions.MQClientException"> </exception>
            <exception cref="!:InterruptedException"> </exception>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.MQHelper”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Client.MQHelper.ResetOffsetByTimestamp(TCBase.Distributed.TurboMQ.Common.Protocol.Heartbeat.MessageModel,System.String,System.String,System.String,System.Int64)">
            <summary>
            Reset consumer topic offset according to time
            </summary>
            <param name="messageModel">
                       which model </param>
            <param name="instanceName">
                       which instance </param>
            <param name="consumerGroup">
                       consumer group </param>
            <param name="topic">
                       topic </param>
            <param name="timestamp">
                       time </param>
            <exception cref="T:System.Exception"> </exception>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Producer.DefaultMQProducer”忽略有格式错误的 XML 注释 -->
        <member name="F:TCBase.Distributed.TurboMQ.Client.Producer.DefaultMQProducer.createTopicKey">
            <summary>
            Just for testing or demo program
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Producer.DefaultMQProducer.Start">
            <summary>
            启动生产者
            </summary>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException">启动异常</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Producer.DefaultMQProducer.Send(TCBase.Distributed.TurboMQ.Common.Message.Message)">
            <summary>
            发消息
            </summary>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException">客户端异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.RemotingException">传输异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQBrokerException">broker异常</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Producer.DefaultMQProducer.Send(TCBase.Distributed.TurboMQ.Common.Message.Message,System.Int64)">
            <summary>
            发消息
            </summary>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException">客户端异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.RemotingException">传输异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQBrokerException">broker异常</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Producer.DefaultMQProducer.Send(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Client.Producer.SendCallback)">
            <summary>
            发消息
            </summary>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException">客户端异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.RemotingException">传输异常</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Producer.DefaultMQProducer.Send(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Client.Producer.SendCallback,System.Int64)">
            <summary>
            发消息
            </summary>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException">客户端异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.RemotingException">传输异常</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Producer.DefaultMQProducer.SendOneway(TCBase.Distributed.TurboMQ.Common.Message.Message)">
            <summary>
            发消息
            </summary>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException">客户端异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.RemotingException">传输异常</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Producer.DefaultMQProducer.Send(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Common.Message.MessageQueue)">
            <summary>
            发消息
            </summary>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException">客户端异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.RemotingException">传输异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQBrokerException">broker异常</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Producer.DefaultMQProducer.Send(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Common.Message.MessageQueue,System.Int64)">
            <summary>
            发消息
            </summary>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException">客户端异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.RemotingException">传输异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQBrokerException">broker异常</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Producer.DefaultMQProducer.Send(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Common.Message.MessageQueue,TCBase.Distributed.TurboMQ.Client.Producer.SendCallback)">
            <summary>
            发消息
            </summary>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException">客户端异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.RemotingException">传输异常</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Producer.DefaultMQProducer.Send(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Common.Message.MessageQueue,TCBase.Distributed.TurboMQ.Client.Producer.SendCallback,System.Int64)">
            <summary>
            发消息
            </summary>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException">客户端异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.RemotingException">传输异常</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Producer.DefaultMQProducer.SendOneway(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Common.Message.MessageQueue)">
            <summary>
            发消息
            </summary>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException">客户端异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.RemotingException">传输异常</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Producer.DefaultMQProducer.Send(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Client.Producer.MessageQueueSelector,System.Object)">
            <summary>
            发消息
            </summary>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException">客户端异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.RemotingException">传输异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQBrokerException">broker异常</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Producer.DefaultMQProducer.Send(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Client.Producer.MessageQueueSelector,System.Object,System.Int64)">
            <summary>
            发消息
            </summary>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException">客户端异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.RemotingException">传输异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQBrokerException">broker异常</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Producer.DefaultMQProducer.Send(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Client.Producer.MessageQueueSelector,System.Object,TCBase.Distributed.TurboMQ.Client.Producer.SendCallback)">
            <summary>
            发消息
            </summary>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException">客户端异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.RemotingException">传输异常</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Producer.DefaultMQProducer.Send(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Client.Producer.MessageQueueSelector,System.Object,TCBase.Distributed.TurboMQ.Client.Producer.SendCallback,System.Int64)">
            <summary>
            发消息
            </summary>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException">客户端异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.RemotingException">传输异常</exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Producer.DefaultMQProducer.SendOneway(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Client.Producer.MessageQueueSelector,System.Object)">
            <summary>
            发消息
            </summary>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException">客户端异常</exception>
            <exception cref="T:TCMSDotNetRocketMQ.Client.Exceptions.RemotingException">传输异常</exception>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Producer.LocalTransactionExecuter”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Producer.LocalTransactionState”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Producer.MessageQueueSelector”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Producer.MQProducer”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Producer.Selector.SelectMessageQueueByHash”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Producer.Selector.SelectMessageQueueByMachineRoom”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Producer.Selector.SelectMessageQueueByRandoom”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Producer.SendCallback”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Producer.SendResult”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Producer.SendStatus”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Producer.TransactionCheckListener”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Producer.TransactionMQProducer”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Producer.TransactionSendResult”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.QueryResult”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.Validators”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Client.Validators.RegularExpressionMatcher(System.String,System.Text.RegularExpressions.Regex)">
            <param name="origin"> </param>
            <param name="pattern">
            @return </param>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Validators.GetGroupWithRegularExpression(System.String,System.String)">
            <param name="origin"> </param>
            <param name="patternStr">
            @return </param>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Validators.CheckTopic(System.String)">
            <summary>
            Validate topic
            </summary>
            <param name="topic"> </param>
            <exception cref="!:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Validators.CheckGroup(System.String)">
            <summary>
            Validate group
            </summary>
            <param name="group"> </param>
            <exception cref="!:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.Validators.CheckMessage(TCBase.Distributed.TurboMQ.Common.Message.Message,TCBase.Distributed.TurboMQ.Client.Producer.DefaultMQProducer)">
            <summary>
            Validate message
            </summary>
            <param name="msg"> </param>
            <param name="defaultMQProducer"> </param>
            <exception cref="!:TCMSDotNetRocketMQ.Client.Exceptions.MQClientException"> </exception>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Client.VirtualEnvUtil”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Client.VirtualEnvUtil.BuildWithProjectGroup(System.String,System.String)">
            <param name="origin"> </param>
            <param name="projectGroup">
            @return </param>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Client.VirtualEnvUtil.ClearProjectGroup(System.String,System.String)">
            <param name="origin"> </param>
            <param name="projectGroup">
            @return </param>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.ConfigManager”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Conflict.PackageConflictDetect”忽略有格式错误的 XML 注释 -->
        <member name="T:TCBase.Distributed.TurboMQ.Common.Constant.DBMsgConstants">
            <summary>
            User: yubao.fyb
            Date: 14/11/13
            Time: 14:11
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Constant.LoggerName”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Constant.PermName”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Consumer.ConsumeFromWhere”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“F:TCBase.Distributed.TurboMQ.Common.Consumer.ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“F:TCBase.Distributed.TurboMQ.Common.Consumer.ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“F:TCBase.Distributed.TurboMQ.Common.Consumer.ConsumeFromWhere.CONSUME_FROM_TIMESTAMP”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.DataVersion”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Filter.FilterAPI”忽略有格式错误的 XML 注释 -->
        <member name="T:TCBase.Distributed.TurboMQ.Common.Filter.Impl.Op">
            <summary>
            @auther lansheng.zj@taobao.com
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Common.Filter.Impl.Operand">
            <summary>
            @auther lansheng.zj@taobao.com
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Common.Filter.Impl.Operator">
            <summary>
            @auther lansheng.zj@taobao.com
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Common.Filter.Impl.PolishExpr">
            <summary>
            @auther lansheng.zj@taobao.com
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Common.Filter.Impl.PolishExpr.Participle(System.String)">
            <summary>
            拆分单词
            </summary>
            <param name="expression">
            @return </param>
            <exception cref="T:System.Exception"> </exception>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Common.Filter.Impl.PolishExpr.ReversePolish(System.String)">
            <summary>
            将中缀表达式转换成逆波兰表达式
            </summary>
            <param name="expression">
            @return </param>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Common.Filter.Impl.PolishExpr.ReversePolish(System.Collections.Generic.IList{TCBase.Distributed.TurboMQ.Common.Filter.Impl.Op})">
            <summary>
            将中缀表达式转换成逆波兰表达式<br/>
            Shunting-yard algorithm <br/>
            http://en.wikipedia.org/wiki/Shunting_yard_algorithm
            </summary>
            <param name="tokens">
            @return </param>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Common.Filter.Impl.Type">
            <summary>
            @auther lansheng.zj@taobao.com
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Common.Filter.MessageFilter">
            <summary>
            服务端消息过滤接口，Consumer实现这个接口后，Consumer客户端会注册这段Java程序到Broker，由Broker来编译并执行，
            以达到服务器消息过滤的目的
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Common.Filter.MessageFilter.Match(TCBase.Distributed.TurboMQ.Common.Message.MessageExt)">
            <summary>
            过滤消息
            </summary>
            <param name="msg"> </param>
            <returns> 是否可以被Consumer消费 </returns>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Help.FAQUrl”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Common.Help.FAQUrl.AttachDefaultURL(System.String)">
            <summary>
            对于没有未异常原因指定FAQ的情况，追加默认FAQ
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Common.Message.Message">
            消息，Producer与Consumer使用
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.Message.Message.topic">
            <summary>
            消息主题
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.Message.Message.flag">
            <summary>
            消息标志，系统不做干预，完全由应用决定如何使用
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.Message.Message.properties">
            <summary>
            消息属性，都是系统属性，禁止应用设置
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.Message.Message.body">
            <summary>
            消息体
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.Message.MessageConst.PROPERTY_KEYS">
            <summary>
            消息关键词，多个Key用KEY_SEPARATOR隔开（查询消息使用）
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.Message.MessageConst.PROPERTY_TAGS">
            <summary>
            消息标签，只支持设置一个Tag（服务端消息过滤使用）
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.Message.MessageConst.PROPERTY_WAIT_STORE_MSG_OK">
            <summary>
            是否等待服务器将消息存储完毕再返回（可能是等待刷盘完成或者等待同步复制到其他服务器）
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.Message.MessageConst.PROPERTY_DELAY_TIME_LEVEL">
            <summary>
            消息延时投递时间级别，0表示不延时，大于0表示特定延时级别（具体级别在服务器端定义）
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.Message.MessageConst.PROPERTY_RETRY_TOPIC">
            <summary>
            内部使用
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Message.MessageDecoder”忽略有格式错误的 XML 注释 -->
        <member name="F:TCBase.Distributed.TurboMQ.Common.Message.MessageDecoder.MSG_ID_LENGTH">
            <summary>
            消息ID定长
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.Message.MessageDecoder.MessageMagicCodePostion">
            <summary>
            存储记录各个字段位置
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Common.Message.MessageDecoder.Decode(TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer,System.Boolean)">
            客户端使用，SLAVE也会使用
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Common.Message.MessageDecoder.Decodes(TCBase.Distributed.TurboMQ.DotNetty.Buffers.IByteBuffer,System.Boolean)">
            <summary>
            客户端使用
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.Message.MessageDecoder.NAME_VALUE_SEPARATOR">
            <summary>
            序列化消息属性
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Common.Message.MessageExt">
            消息扩展属性，在服务器上产生此对象
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Common.Message.MessageExt.SocketAddress2ByteBuffer(System.Net.EndPoint)">
            <summary>
            SocketAddress ----> ByteBuffer 转化成8个字节
            </summary>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.Common.Message.MessageExt.BornHostBytes">
            <summary>
            获取bornHost字节形式，8个字节 HOST + PORT
            </summary>
        </member>
        <member name="P:TCBase.Distributed.TurboMQ.Common.Message.MessageExt.StoreHostBytes">
            <summary>
            获取storehost字节形式，8个字节 HOST + PORT
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Message.MessageQueue”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.MixAll”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Common.MixAll.String2File(System.String,System.String)">
            <summary>
            安全的写文件
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Common.MixAll.Object2Properties(System.Object)">
            <summary>
            将对象各成员属性值转化为Properties
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.MQVersion”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Namesrv.NamesrvUtil”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Namesrv.TopAddressing”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Pair`2”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Body.Connection”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Body.ConsumeByWho”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Body.ConsumerOffsetSerializeWrapper”忽略有格式错误的 XML 注释 -->
        <member name="T:TCBase.Distributed.TurboMQ.Common.Protocol.Body.ConsumerRunningInfo">
            <summary>
            Consumer内部数据结构
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Common.Protocol.Body.ConsumeStatus">
            <summary>
            消费过程的统计数据
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Body.GetConsumerStatusBody”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Body.GroupList”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Body.LockBatchRequestBody”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Body.LockBatchResponseBody”忽略有格式错误的 XML 注释 -->
        <member name="F:TCBase.Distributed.TurboMQ.Common.Protocol.Body.ProcessQueueInfo.commitOffset">
            <summary>
            消费到哪里，提交的offset
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.Protocol.Body.ProcessQueueInfo.cachedMsgMinOffset">
            <summary>
            缓存的消息Offset信息
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.Protocol.Body.ProcessQueueInfo.transactionMsgMinOffset">
            <summary>
            正在事务中的消息
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.Protocol.Body.ProcessQueueInfo.locked">
            <summary>
            顺序消息的状态信息
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Body.QueryConsumeTimeSpanBody”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Body.QueueTimeSpan”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Body.ResetOffsetBody”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Body.SubscriptionGroupWrapper”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Body.UnlockBatchRequestBody”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.CheckTransactionStateRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.ConsumerSendMsgBackRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.CreateTopicRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.DeleteTopicRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.EndTransactionRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.EndTransactionResponseHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.GetAllTopicConfigResponseHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.GetBrokerConfigResponseHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.GetConsumerListByGroupRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.GetConsumerListByGroupResponseBody”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.GetConsumerListByGroupResponseHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.GetConsumerRunningInfoRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.GetConsumerStatusRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.GetConsumeStatsRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.GetEarliestMsgStoretimeRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.GetEarliestMsgStoretimeResponseHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.GetMaxOffsetRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.GetMaxOffsetResponseHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.GetMinOffsetRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.GetMinOffsetResponseHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.GetProducerConnectionListRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.GetTopicsByClusterRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.GetTopicStatsInfoRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.Namesrv.DeleteKVConfigRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.Namesrv.DeleteTopicInNamesrvRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.Namesrv.GetKVConfigRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.Namesrv.GetKVConfigResponseHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.Namesrv.GetKVListByNamespaceRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.Namesrv.GetRouteInfoRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.Namesrv.GetRouteInfoResponseHeader”忽略有格式错误的 XML 注释 -->
        <member name="T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.Namesrv.RegisterBrokerRequestHeader">
            <summary>
            @author lansheng.zj@taobao.com
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.Namesrv.RegisterBrokerResponseHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.Namesrv.RegisterOrderTopicRequestHeader”忽略有格式错误的 XML 注释 -->
        <member name="T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.Namesrv.UnRegisterBrokerRequestHeader">
            <summary>
            @author lansheng.zj@taobao.com
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.Namesrv.WipeWritePermOfBrokerRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.Namesrv.WipeWritePermOfBrokerResponseHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.NotifyConsumerIdsChangedRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.PullMessageRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.PullMessageResponseHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.QueryConsumerOffsetRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.QueryConsumerOffsetResponseHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.QueryConsumeTimeSpanRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.QueryCorrectionOffsetHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.QueryMessageRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.QueryMessageResponseHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.QueryTopicConsumeByWhoRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.ResetOffsetRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.SearchOffsetRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.SearchOffsetResponseHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.SendMessageRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.SendMessageRequestHeaderV2”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.SendMessageResponseHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.UnregisterClientRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.UnregisterClientResponseHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.UpdateConsumerOffsetRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.UpdateConsumerOffsetResponseHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.ViewMessageRequestHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Header.ViewMessageResponseHeader”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Heartbeat.ConsumerData”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Heartbeat.ConsumeType”忽略有格式错误的 XML 注释 -->
        <member name="F:TCBase.Distributed.TurboMQ.Common.Protocol.Heartbeat.ConsumeType.CONSUME_ACTIVELY">
            <summary>
            主动方式消费
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.Protocol.Heartbeat.ConsumeType.CONSUME_PASSIVELY">
            <summary>
            被动方式消费
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Heartbeat.HeartbeatData”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Heartbeat.MessageModel”忽略有格式错误的 XML 注释 -->
        <member name="F:TCBase.Distributed.TurboMQ.Common.Protocol.Heartbeat.MessageModel.BROADCASTING">
            <summary>
            broadcast
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.Protocol.Heartbeat.MessageModel.CLUSTERING">
            <summary>
            clustering
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Heartbeat.ProducerData”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Heartbeat.SubscriptionData”忽略有格式错误的 XML 注释 -->
        <member name="F:TCBase.Distributed.TurboMQ.Common.Protocol.Heartbeat.SubscriptionData.filterClassSource">
            <summary>
            Java过滤类，通过专有的上传接口上传到Filter Server
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Route.BrokerData”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Common.Protocol.Route.BrokerData.SelectBrokerAddr">
            <summary>
            优先获取Master，如果没有Master尝试找Slave
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Protocol.Route.TopicRouteData”忽略有格式错误的 XML 注释 -->
        <member name="F:TCBase.Distributed.TurboMQ.Common.Protocol.Topic.OffsetMovedEvent.offsetRequest">
            <summary>
            客户端请求的Offset
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.Protocol.Topic.OffsetMovedEvent.offsetNew">
            <summary>
            Broker要求从这个新的Offset开始消费
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.ServiceState”忽略有格式错误的 XML 注释 -->
        <member name="F:TCBase.Distributed.TurboMQ.Common.ServiceState.CREATE_JUST">
            <summary>
            Service just created,not start
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.ServiceState.RUNNING">
            <summary>
            Service Running
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.ServiceState.SHUTDOWN_ALREADY">
            <summary>
            Service shutdown
            </summary>
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Common.ServiceState.START_FAILED">
            <summary>
            Service Start failure
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.ServiceThread”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Subscription.SubscriptionGroupConfig”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Sysflag.MessageSysFlag”忽略有格式错误的 XML 注释 -->
        <member name="F:TCBase.Distributed.TurboMQ.Common.Sysflag.MessageSysFlag.CompressedFlag">
            <summary>
            SysFlag
            </summary>
        </member>
        <!-- 对于成员“F:TCBase.Distributed.TurboMQ.Common.Sysflag.MessageSysFlag.TransactionNotType”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Sysflag.PullSysFlag”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Sysflag.SubscriptionSysFlag”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Sysflag.TopicSysFlag”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.TopicConfig”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.TopicFilterType”忽略有格式错误的 XML 注释 -->
        <member name="F:TCBase.Distributed.TurboMQ.Common.TopicFilterType.SINGLE_TAG">
            <summary>
            每个消息只能有一个Tag
            </summary>
        </member>
        <!-- 对于成员“F:TCBase.Distributed.TurboMQ.Common.TopicFilterType.MULTI_TAG”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.UtilAll”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“M:TCBase.Distributed.TurboMQ.Common.UtilAll.TimeMillisToHumanString3(System.Int64)”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Common.UtilAll.Bytes2string(System.Byte[])">
            <summary>
            字节数组转化成16进制形式
            </summary>
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Common.UtilAll.String2bytes(System.String)">
            <summary>
            16进制字符串转化成字节数组
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Common.Utils.HttpTinyClient”忽略有格式错误的 XML 注释 -->
        <member name="M:TCBase.Distributed.TurboMQ.Common.Utils.HttpTinyClient.HttpGet(System.String,System.Int64)">
            <summary>
            发送GET请求。
            </summary>
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Remoting.CommandCustomHeader”忽略有格式错误的 XML 注释 -->
        <member name="T:TCBase.Distributed.TurboMQ.Remoting.Common.RemotingHelper">
            通信层一些辅助方法
        </member>
        <!-- 对于成员“T:TCBase.Distributed.TurboMQ.Remoting.Common.RemotingUtil”忽略有格式错误的 XML 注释 -->
        <member name="T:TCBase.Distributed.TurboMQ.Remoting.Common.SemaphoreReleaseOnlyOnce">
            使用布尔原子变量，信号量保证只释放一次
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Remoting.Common.ServiceThread">
            Base class for background thread
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Remoting.Exceptions.RemotingConnectException">
            Client连接Server失败，抛出此异常
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Remoting.Exceptions.RemotingException">
            通信层异常父类
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Remoting.Exceptions.RemotingSendRequestException">
            RPC调用中，客户端发送请求失败，抛出此异常
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Remoting.Exceptions.RemotingTimeoutException">
            RPC调用超时异常
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Remoting.Exceptions.RemotingTooMuchRequestException">
            异步调用或者Oneway调用，堆积的请求超过信号量最大值
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Remoting.InvokeCallback">
            异步调用应答回调接口
        </member>
        <member name="F:TCBase.Distributed.TurboMQ.Remoting.Netty.NettyClientConfig.clientChannelMaxIdleTimeSeconds">
            <summary>
            IdleStateEvent will be triggered when neither read nor write was performed for
            the specified period of this time. Specify {@code 0} to disable
            </summary>
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Remoting.Netty.NettyEvent">
            Netty产生的各种事件
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Remoting.Netty.NettyRemotingAbstract">
            Server与Client公用抽象类
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Remoting.Netty.NettyRemotingClient">
            Remoting客户端实现
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Remoting.Netty.NettyRequestProcessor">
            Common remoting command processor
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Remoting.Netty.ResponseFuture">
            异步请求应答封装
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Remoting.Protocol.RemotingCommand.MakeCustomHeaderToNet">
            将自定义头部转换成Map
        </member>
        <member name="M:TCBase.Distributed.TurboMQ.Remoting.Protocol.RemotingCommand.EncodeHeader(System.Int32)">
            只打包Header，body部分独立传输
        </member>
        <member name="T:TCBase.Distributed.TurboMQ.Remoting.RemotingClient">
            远程通信，Client接口
        </member>
    </members>
</doc>
